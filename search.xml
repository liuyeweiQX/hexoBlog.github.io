<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JPA</title>
    <url>/2020/08/12/JPA/</url>
    <content><![CDATA[<h3 id="JPA是什么"><a href="#JPA是什么" class="headerlink" title="JPA是什么"></a>JPA是什么</h3><p>JPA（Java Persistence API）Java持久化API。是一套sun公司Java官方制定的ORM方案，是规范，是标准，sun公司自己并没有实现。</p>
<p><strong>关键点：ORM，标准 概念(关键字)</strong></p>
<h3 id="ORM是什么"><a href="#ORM是什么" class="headerlink" title="ORM是什么"></a>ORM是什么</h3><p>ORM（Object Relational Mapping）对象关系映射。问：ORM有什么用？在操作数据库之前，先把数据表与实体类关联起来。然后通过实体类的对象操作（增删改查）数据库表，这个就是ORM的行为！所以：ORM是一个实现使用对象操作数据库的设计思想！通过这句话，我们知道JPA的作用就是通过对象操作数据库的，不用编写sql语句。</p>
<h3 id="JPA的实现者"><a href="#JPA的实现者" class="headerlink" title="JPA的实现者"></a>JPA的实现者</h3><p>既然我们说JPA是一套标准，意味着，它只是一套实现ORM理论的接口。没有实现的代码。那么我们必须要有具体实现者才可以完成ORM操作功能的实现！ </p>
<p>市场上主流的JPA框架（实现者）有：Hibernate(JBoss)、EclipseTop(Eclipse社区)、OpenJPA(Apache基金会)其中Hibernate是众多实现者之中，性能最好的。</p>
<h3 id="JPA的作用是什么"><a href="#JPA的作用是什么" class="headerlink" title="JPA的作用是什么"></a>JPA的作用是什么</h3><p>JPA是ORM的一套标准，既然JPA为ORM而生，那么JPA的作用就是实现使用对象操作数据库，不用写SQL</p>
<p>数据库是用sql操作的，那用对象操作，由谁来产生SQL?</p>
<p>答：JPA实现框架</p>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul>
<li><p>实体（pojo）表示关系数据库中的一个表</p>
</li>
<li><p>每个实体实例对应着该表中的一行</p>
</li>
<li><p>类必须用javax.persistence.Entity注解</p>
</li>
<li><p>类必须含有一个public或者protected的无参构造函数</p>
</li>
<li><p>当实体实例被当做值以分离对象的方式进行传递（例如通过会话bean的远程业务接口）则该类必须实现Serializable（序列化）接口</p>
</li>
<li><p>唯一的对象标志符，简单主键（javax.persistence.Id），复合主键（javax.persistence.EmbeddledId和javax.persistence.IdClass）</p>
</li>
</ul>
<h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul>
<li><p>一对一：@OneToOne</p>
</li>
<li><p>一对多：@OneToMany</p>
</li>
<li><p>多对一：@ManyToOne</p>
</li>
<li><p>多对多：@ManyToMany</p>
</li>
</ul>
<h3 id="EntityManager"><a href="#EntityManager" class="headerlink" title="EntityManager"></a>EntityManager</h3><ul>
<li><p>管理实体的一个类，接口</p>
</li>
<li><p>定义与持久性上下文进行交互的方法</p>
</li>
<li><p>创建和删除持久实体类，通过实体的主键查找实体</p>
</li>
<li><p>允许在实体类上进行查询</p>
</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown小结</title>
    <url>/2020/08/03/Markdown%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<h4 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**这是加粗字段**</span><br><span class="line">__这也是加粗字段__</span><br></pre></td></tr></table></figure>

<h4 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*这是倾斜字段*</span><br><span class="line">_这也是倾斜字段_</span><br></pre></td></tr></table></figure>

<h4 id="又斜又粗"><a href="#又斜又粗" class="headerlink" title="又斜又粗"></a>又斜又粗</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">***斜粗字段***</span><br></pre></td></tr></table></figure>

<h4 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;这是高亮字段&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<h4 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2^2^</span><br></pre></td></tr></table></figure>

<h4 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">H~2~o</span><br></pre></td></tr></table></figure>

<h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~加删除线的字段~~</span><br></pre></td></tr></table></figure>

<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;+一个空格+字段</span><br><span class="line">&gt;+五个空格+字段，引用代码块</span><br><span class="line">可以加若干个&gt;嵌套。多级引用</span><br></pre></td></tr></table></figure>

<h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">****</span><br></pre></td></tr></table></figure>

<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 &quot;图片title&quot;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>

<h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br><span class="line">如果想要在新页面中打开的话可以用html语言的a标签代替。</span><br><span class="line">&lt;a href&#x3D;&quot;超链接地址&quot; target&#x3D;&quot;_blank&quot;&gt;超链接名&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>
<h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>
<p>列表嵌套<br>上一级和下一级之间敲三个空格即可</p>
<h4 id="表头"><a href="#表头" class="headerlink" title="表头"></a>表头</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br></pre></td></tr></table></figure>

<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>单行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\&#96;代码内容\&#96;</span><br></pre></td></tr></table></figure>
<p>代码块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\&#96;\&#96;\&#96;</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">\&#96;\&#96;\&#96;</span><br></pre></td></tr></table></figure>
<p>(使用时 反斜杠去掉)</p>
<h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">op&#x3D;&gt;operation: My Operation</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?</span><br><span class="line">e&#x3D;&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>

<h4 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h4><p>行内嵌</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\sum_&#123;i&#x3D;1&#125;^&#123;10&#125;f(i)\,\,\text&#123;thanks&#125;$</span><br></pre></td></tr></table></figure>
<p>块状</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\sum_&#123;i&#x3D;1&#125;^&#123;10&#125;f(i)\,\,\text&#123;thanks&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<h4 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h4><p>脚注和注脚一样吗，好像没区别<br>确保 [-] 里面的内容与底部的一致即可，可以是中文</p>
<h4 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h4><p>jump 可以用其他字符或字符串代替，id 一致即可<br>效果与脚注类似，可以跳转之文中任意位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[说明文字](#jump)</span><br><span class="line">&lt;span id&#x3D;&quot;jump&quot;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h4><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号<br>例如：你想要用星号加在文字旁边的方式来做出强调效果（为了避免冲突）<br>你可以在星号的前面加上反斜杠，如果不加 \，# 后就会变为一级标题<br>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号</p>
<h4 id="转义箭头"><a href="#转义箭头" class="headerlink" title="转义箭头"></a>转义箭头</h4><p>\to 或 \rightarrow 与前面无空格<br>注意后面有空格！<br>之间若想空格，用 \ 加空格表示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$A\to B$</span><br><span class="line">$C\rightarrow D$</span><br><span class="line">$C\Rightarrow D$</span><br><span class="line">$E\longrightarrow F$</span><br><span class="line">$A\Longleftrightarrow B$</span><br><span class="line">$A\xrightarrow&#123;\ \ \ \ 20km\quad&#125; B$</span><br><span class="line">$Beijin\xrightarrow&#123;10991km)\quad&#125; New York$</span><br></pre></td></tr></table></figure>

<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">居左：:----</span><br><span class="line">居中：:----:或-----</span><br><span class="line">居右：----:</span><br><span class="line"></span><br><span class="line">|标题|标题|标题|</span><br><span class="line">|:---|:---:|---:|</span><br><span class="line">|居左测试|居中测试|居右测试|</span><br><span class="line">|居左测试1|居中测试1|居右测试1|</span><br><span class="line">|居左测试2|居中测试2|居右测试2|</span><br><span class="line">|居左测试3|居中测试3|居右测试3|</span><br><span class="line"></span><br><span class="line">为了效果，我只能用HTML强制渲染了</span><br><span class="line">|标题|标题|标题|</span><br><span class="line">|:---|:---:|---:|</span><br><span class="line">|居左测试|&lt;center&gt;居中测试&lt;&#x2F;center&gt;|&lt;p align&#x3D;&quot;right&quot;&gt;居右测试&lt;&#x2F;p&gt;|</span><br><span class="line">|居左测试1|&lt;center&gt;居中测试1&lt;&#x2F;center&gt;|&lt;p align&#x3D;&quot;right&quot;&gt;居右测试1&lt;&#x2F;p&gt;|</span><br><span class="line">|居左测试2|&lt;center&gt;居中测试2&lt;&#x2F;center&gt;|&lt;p align&#x3D;&quot;right&quot;&gt;居右测试2&lt;&#x2F;p&gt;|</span><br><span class="line">|居左测试3|&lt;center&gt;居中测试3&lt;&#x2F;center&gt;|&lt;p align&#x3D;&quot;right&quot;&gt;居右测试3&lt;&#x2F;p&gt;|</span><br></pre></td></tr></table></figure>

<h4 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h4><p>任务列表即待办事项，表现为 方框 与 钩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- [x] 早餐（已完成）</span><br><span class="line">- [ ] 喝水</span><br><span class="line">- [ ] 学习</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<ul>
<li><input checked disabled type="checkbox"> 早餐（已完成）</li>
<li><input disabled type="checkbox"> 喝水</li>
<li><input disabled type="checkbox"> 学习</li>
</ul>
<p>基础markdown语法参考：<a href="https://www.appinn.com/markdown/">https://www.appinn.com/markdown/</a><br>插入数学公式markdown语法参考：<a href="https://www.zybuluo.com/codeep/note/163962">https://www.zybuluo.com/codeep/note/163962</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>内外部类互访</title>
    <url>/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/</url>
    <content><![CDATA[<h3 id="内部类访问外部类"><a href="#内部类访问外部类" class="headerlink" title="内部类访问外部类"></a>内部类访问外部类</h3><p>里面的可以自由访问外面的，规则和static一样。（访问非静态时必须先创建对象）具体如下：</p>
<ul>
<li><p>非静态内部类的非静态方法 直接访问</p>
<p>直接访问</p>
<img src= "/img/loading.gif" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content1.png" class title="content1">
</li>
<li><p>静态内部类的非静态方法</p>
<p>因为静态方法访问非静态外部成员需先创建实例，所以访问i时必须先new外部类。</p>
<img src= "/img/loading.gif" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content2.png" class title="content2">
</li>
<li><p>静态内部类的静态方法</p>
<p>规则如上</p>
<img src= "/img/loading.gif" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content3.png" class title="content3">

</li>
</ul>
<h3 id="外部类访问内部类"><a href="#外部类访问内部类" class="headerlink" title="外部类访问内部类"></a>外部类访问内部类</h3><p>大方向：因为将内部类理解为外部类的一个普通成员，所以外面的访问里面的需先new一个对象。</p>
<ul>
<li><p>非静态方法访问非静态内部类的成员：</p>
<p>new 内部类对象</p>
<img src= "/img/loading.gif" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content4.png" class title="content4">
</li>
<li><p>静态方法访问非静态内部类的成员</p>
<p>静态方法Test2访问非静态Inner1需先new外部类；</p>
<p>继续访问非静态成员i需先new 内部类</p>
<p>所以访问规则为：new Outter().new Inner1().i。</p>
<img src= "/img/loading.gif" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content5.png" class title="content5">
</li>
<li><p>非静态方法访问静态内部类的成员</p>
<p>先“外部类.内部类”访问至内部类。</p>
<p>若访问静态成员，则需先new再访问；若访问非静态成员，则可直接访问。</p>
<img src= "/img/loading.gif" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content6.png" class title="content6">
</li>
<li><p>非静态方法访问非静态内部类的成员</p>
<p>先“外部类.内部类”访问至内部类，再new即可访问静态成员。</p>
<img src= "/img/loading.gif" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content7.png" class title="content7">

</li>
</ul>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类访问外部成员变量时，成员变量前应加final关键字。</p>
<img src= "/img/loading.gif" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content8.png" class title="content8">















]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>内外部类</tag>
      </tags>
  </entry>
  <entry>
    <title>唯一索引和非唯一索引</title>
    <url>/2020/08/12/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>非唯一索引也叫普通索引</p>
<p>如果在一个列上同时建唯一索引和普通索引的话，mysql 会自动选择唯一索引 唯一索引和普通索引使用的结构都是 B-tree，执行时间复杂度都是 O(log n)</p>
<h3 id="普通索引（非唯一索引）"><a href="#普通索引（非唯一索引）" class="headerlink" title="普通索引（非唯一索引）"></a>普通索引（非唯一索引）</h3><p>普通索引（由关键字 KEY 或 INDEX 定义的索引）的唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（WHERE column =）或排序条件（ORDER BY column）中的数据列创建索引。只要有可能，就应该选择一个数据最整齐、最紧凑的数据列（如一个整数类型的数据列）来创建索引。</p>
<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>普通索引允许被索引的数据列包含重复的值</p>
<p>如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字 UNIQUE 把它定义为一个唯一索引。这么做的好处：一是简化了 MySQL 对这个索引的管理工作，这个索引也因此而变得更有效率（区分度：distinct * / count (*) 高）；二是 MySQL 会在有新记录插入数据表时，自动检查新记录的这个字段的值是否已经在某个记录的这个字段里出现过了；如果是，MySQL 将拒绝插入那条新记录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。</p>
<h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>主键索引是唯一索引的特殊类型</p>
<p>数据库表通常有一列或列组合，其值用来唯一标识表中的每一行。该列称为表的主键 在数据库关系图中为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的。当在查询中使用主键索引时，它还允许快速访问数据 </p>
<p>它们的一些比较： </p>
<ol>
<li><p>对于主键 MySQL 会自动建立唯一索引；</p>
</li>
<li><p>主键不一定只包含一个字段，所以可以在主键的其中一个字段建唯一索引； </p>
</li>
<li><p>主键可作外键，唯一索引不可；</p>
</li>
<li><p>主键不可为空，唯一索引可； </p>
</li>
<li><p>主键也可是多个字段的组合； </p>
</li>
</ol>
<p>主键与唯一索引不同的是： </p>
<ol>
<li><p>有not null属性； </p>
</li>
<li><p>每个表只能有一个。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列</title>
    <url>/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h3><p>可以把消息队列比作是一个存放消息的容器。消息队列是分布式系统中重要的组件，使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。目前使用较多的消息队列有ActiveMQ，RabbitMQ，Kafka，RocketMQ。</p>
<p>另外，队列Queue是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。比如生产者发送消息1,2,3…对于消费者就会按照1,2,3…的顺序来消费。但是偶尔也会出现消息被消费的顺序不对的情况，比如某个消息消费失败又或者一个queue多个consumer也会导致消息被消费的顺序不对，我们一定要保证消息被消费的顺序正确。</p>
<p>除了上面说的消息消费顺序的问题，使用消息队列，还要考虑如何保证消息不被重复消费？如何保证消息的可靠性传输（如何处理消息丢失的问题）？……等等问题。所以说使用消息队列也不是十全十美的，使用它也会让系统可用性降低、复杂度提高，另外需要我们保障一致性等问题。</p>
<h3 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h3><p>使用消息队列主要有两点好处：</p>
<ol>
<li>通过异步处理提高系统性能（削峰、减少响应所需时间）；</li>
<li>降低系统耦合性。</li>
</ol>
<p><strong>（1）通过异步处理提高系统性能（削峰、减少响应所需时间)</strong></p>
<img src= "/img/loading.gif" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content1.png" class title="消息队列1">
<p>如上图，<strong>在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求发送给消息队列之后立即返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善</strong>。</p>
<p>通过以上分析可以得出<strong>消息队列具有很好的削峰作用的功能——即通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务</strong>。举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：</p>
<img src= "/img/loading.gif" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content2.png" class title="content2">
<p>因为<strong>用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败</strong>。因此使用消息队列进行异步处理之后，需要<strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p>
<p><strong>（2）降低系统耦合性</strong><br>如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。<br>最常见的<strong>事件驱动架构</strong>类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。如下图所示：</p>
<img src= "/img/loading.gif" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content3.png" class title="content3">
<p><strong>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接收者（消费者）订阅消息</strong>。从上图可以看到<strong>消息发送者（生产者）和消息接收者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接收者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。<br>消息接收者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p>
<p><strong>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息</strong>。</p>
<p><strong>备注</strong>：不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。<strong>除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式</strong>。另外，这两者消息模型是JMS提供的，AMQP协议还提供了5种消息模型。</p>
<h3 id="使用消息队列带来的一些问题"><a href="#使用消息队列带来的一些问题" class="headerlink" title="使用消息队列带来的一些问题"></a>使用消息队列带来的一些问题</h3><ul>
<li>系统可用性降低：系统可用性在某种程度上降低，在加入MQ之前，不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后就需要去考虑了！</li>
<li>系统复杂性提高：加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li>
<li>一致性问题：上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了！</li>
</ul>
<h3 id="JMS-VS-AMQP"><a href="#JMS-VS-AMQP" class="headerlink" title="JMS VS AMQP"></a>JMS VS AMQP</h3><h4 id="JMS简介"><a href="#JMS简介" class="headerlink" title="JMS简介"></a>JMS简介</h4><p>JMS（JAVA Message Service，java消息服务）是Java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。<strong>JMS API是一个消息服务的标准或者说是规范</strong>，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。<br><strong>ActiveMQ就是基于JMS规范实现的</strong>。</p>
<h4 id="JMS两种消息模型"><a href="#JMS两种消息模型" class="headerlink" title="JMS两种消息模型"></a>JMS两种消息模型</h4><ol>
<li><p>点到点（P2P）模型</p>
<img src= "/img/loading.gif" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content4.png" class title="content4">
<p>使用<strong>队列（Queue）</strong>作为消息通信载体；满足<strong>生产者与消费者模式</strong>，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：生产者发送100条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费）</p>
</li>
<li><p>发布/订阅（Pub/Sub）模型</p>
<img src= "/img/loading.gif" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content5.png" class title="content5">
<p>发布订阅模型（Pub/Sub）使用<strong>主题（Topic）</strong>作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p>
</li>
</ol>
<h4 id="JMS五种不同的消息正文格式"><a href="#JMS五种不同的消息正文格式" class="headerlink" title="JMS五种不同的消息正文格式"></a>JMS五种不同的消息正文格式</h4><p>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有的消息格式的一些级别的兼容性。</p>
<ul>
<li>StreamMessage – Java原始值的数据流</li>
<li>MapMessage – 一套名称-值对</li>
<li>TextMessage – 一套字符串对象</li>
<li>ObjectMessage – 一个序列化的Java对象</li>
<li>BytesMessage – 一个字节的数据流</li>
</ul>
<h4 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h4><p>AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准<strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。<br><strong>RabbitMQ就是基于AMQP协议实现的。</strong></p>
<img src= "/img/loading.gif" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content6.png" class title="content6">
<p><strong>总结：</strong></p>
<ul>
<li>AMQP为消息定义了线路层（wire-level protocol）的协议，而JMS所定义的是API规范。在Java体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而AMQP天然具有跨平台、跨语言特性</li>
<li>JMS 支持TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）</li>
<li>由于Exchange 提供的路由算法，AMQP可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持队列和主题/订阅方式两种</li>
</ul>
<h3 id="常见的消息队列对比"><a href="#常见的消息队列对比" class="headerlink" title="常见的消息队列对比"></a>常见的消息队列对比</h3><img src= "/img/loading.gif" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content7.png" class title="content7">
<p>总结：</p>
<ul>
<li>ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用</li>
<li>RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。</li>
<li>RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ 挺好的</li>
<li>kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</li>
</ul>
]]></content>
      <categories>
        <category>Java进阶</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>类的加载方式</title>
    <url>/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="加载方式"><a href="#加载方式" class="headerlink" title="加载方式"></a>加载方式</h3><ol>
<li>隐式加载：new</li>
<li>显式加载：ClassLoader.loadClass和Class.forName</li>
</ol>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>方式1：<br>new通过关键字 然后通过不同的构造器直接创建实例。如：new String() ，new String(“test”)</p>
<p>方式2：<br>需要加载.class文件获取Class对象，通过Class对象，获取构造器，然后调用newInstance方法创建对象实例。</p>
<img src= "/img/loading.gif" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/content1.png" class title="content1">

<h3 id="ClassLoader-loadClass和Class-forName的区别"><a href="#ClassLoader-loadClass和Class-forName的区别" class="headerlink" title="ClassLoader.loadClass和Class.forName的区别"></a>ClassLoader.loadClass和Class.forName的区别</h3><p>Class的装载包括3个步骤：加载（loading），连接（link），初始化（initialize）<br>参考：类的加载过程文档</p>
<p><strong>Class.forName:</strong></p>
<img src= "/img/loading.gif" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/content2.png" class title="content2">
<p>forName0第二个参数initialize初始化 这里参数是true说明是初始化过的，因此，静态代码块和静态变量是会被执行和初始化的<br><strong>ClassLoader.loadClass:</strong>  </p>
<img src= "/img/loading.gif" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/content3.png" class title="content3">
<p>第二参数resolve，注释中说明这个参数代表是否链接（类加载过程中的链接过程）ClassLoader.loadClass在加载类的过程中只走了第一步</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><img src= "/img/loading.gif" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/content4.png" class title="content4">
<img src= "/img/loading.gif" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/content5.png" class title="content5">
<img src= "/img/loading.gif" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/content6.png" class title="content6">

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Class.forName得到的class是已经初始化<br>ClassLoader.loadeClass得到的class是还没有链接的</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title>类的加载过程</title>
    <url>/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="Java-类加载机制"><a href="#Java-类加载机制" class="headerlink" title="Java 类加载机制"></a>Java 类加载机制</h3><p>类从被加载到JVM中开始，到卸载为止，整个生命周期包括：<strong>加载、验证、准备、解析、初始化、使用和卸载七个阶段</strong>。<br>其中类加载过程包括加载、验证、准备、解析和初始化五个阶段。</p>
<img src= "/img/loading.gif" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/content1.png" class title="content1">

<h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol>
<li>通过类加载器，加载.class文件到内存中。</li>
<li>将读取到.classs数据存储到运行时内存区的方法区。</li>
<li>然后将其转换为一个与目标类型对应的java.lang.Class对象实例。这个Class对象在日后就会作为方法区中该类的各种数据的访问入口。</li>
</ol>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>确保被加载的类（.class文件的字节流），是否按照java虚拟的规范。不会造成安全问题</p>
<ol>
<li>文件格式验证:<br>第一阶段要验证字节流是否符合 Class文件格式的规范, 井且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：</li>
</ol>
<ul>
<li>是否以魔数 0xCAFEBABE开头</li>
<li>主、次版本号是否在当前虚拟机处理范围之内。</li>
<li>常量池的常量中是否有不被支持的常量类型(检査常量tag 标志)。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合装型的常量。</li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合 UTF8编码的数据</li>
<li>Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息 实际上第一阶段的验证点还远不止这些, 这是其中的一部分。只有通过了这个阶段的验证之后, 字节流才会进入内存的方法区中进行存储, 所以后面的三个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。</li>
</ul>
<ol start="2">
<li>元数据验证<br>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求,这个阶段可能包括的验证点如下:</li>
</ol>
<ul>
<li>这个类是否有父类(除了java.lang.object之外,所有的类都应当有父类)</li>
<li>这个类的父类是否继承了不允许被继承的类(被finaI修饰的类)<br>如果这个类不是抽象类, 是否实現了其父类或接口之中要求实现的所有方法类中的字段、方法是否与父类产生了矛盾(例如覆盖了父类的final字段, 或者出現不符合规则的方法重载, 例如方法参数都一致, 但返回值类型却不同等) 第二阶段的验证点同样远不止这些，这一阶段的主要目的是对类的元数据信息进行语义检验, 保证不存在不符合 Java语言规范的元数据信息。</li>
</ul>
<ol start="3">
<li>字节码验证<br>第三阶段是整个验证过程中最复杂的一个阶段, 主要目的是通过数据流和控制流的分析，确定语义是合法的。符号逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如：</li>
</ol>
<ul>
<li>保证任意时刻操作数栈的数据装型与指令代码序列都能配合工作, 例如不会出现类似这样的情况:在操作栈中放置了一个 int类型的数据, 使用时却按long类型来加载入本地变量表中。</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上</li>
<li>保证方法体中的类型转换是有效的, 例如可以把一个子类对象赋值给父类数据装型，这是安全的,但是把父类对象意赋值给子类数据类型,甚至把对象赋值给与它毫无继承关系、 完全不相干的一个数据类型, 则是危险和不合法的。 即使一个方法体通过了字节码验证, 也不能说明其一定就是安全的。</li>
</ul>
<ol start="4">
<li>符号引用验证<br>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候, 这个转化动作将在连接的第三个阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外(常量池中的各种符号引用) 的信息进行匹配性的校验, 通常需要校验以下内容:</li>
</ol>
<ul>
<li>符号引用中通过字将串描述的全限定名是否能找到对应的类</li>
<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段 。</li>
<li>符号引用中的类、字段和方法的访问性(private、 protected、 public、 default)是否可被当前     类访问</li>
<li>符号引用验证的目的是确保解析动作能正常执行, 如果无法通过符号引用验证, 将会抛出一个java.lang.IncompatibleClassChangError异常的子类, 如 java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</li>
</ul>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>主要是为类变量（注意，不是实例变量）分配内存，并且赋予初值，此时的赋值是Java虚拟机根据不同变量类型的默认初始值：<br>如8种基本类型的初值，默认为0；引用类型的初值则为null；常量的初值即为代码中设置的值<br> 1、final static temp = 100，此时temp就是赋值 100。<br> 2、String temp = “123456”，此时temp值就是null。<br> 3、int temp = 100，此时temp值就是0。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>将类的二进制数据中的符号引用替换成直接引用（符号引用是用一组符号描述所引用的目标；直接引用是指向目标的指针）<br>可以认为是一些静态绑定的会被解析，动态绑定则只会在运行时进行解析；静态绑定包括一些final方法(不可以重写),static方法(只会属于当前类)，构造器(不会被重写)<br>在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化，则是为标记为常量值的字段赋值的过程。<br>换句话说，只对static修饰的变量或语句块进行初始化。<br>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。<br>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</p>
<h3 id="涉及问题"><a href="#涉及问题" class="headerlink" title="涉及问题"></a>涉及问题</h3><p>一个类的构造器，代码块，静态代码块，成员变量的的执行顺序。</p>
<img src= "/img/loading.gif" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/content2.png" class title="content2">
<img src= "/img/loading.gif" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/content3.png" class title="content3">
<img src= "/img/loading.gif" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/content4.png" class title="content4">                                                                                                                                                   ]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title>自动拆装箱</title>
    <url>/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/</url>
    <content><![CDATA[<h3 id="什么是自动装箱和拆箱"><a href="#什么是自动装箱和拆箱" class="headerlink" title="什么是自动装箱和拆箱"></a>什么是自动装箱和拆箱</h3><p>自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类型byte, short, char, int, long, float, double 和 boolean 对应的封装类为Byte, Short, Character, Integer, Long, Float, Double, Boolean。</p>
<p>下面例子是自动装箱和拆箱带来的疑惑               </p>
<img src= "/img/loading.gif" data-lazy-src="/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/content1.png" class title="content1"> 
<img src= "/img/loading.gif" data-lazy-src="/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/content2.png" class title="content2">    

<h3 id="自动装箱和拆箱的原理"><a href="#自动装箱和拆箱的原理" class="headerlink" title="自动装箱和拆箱的原理"></a>自动装箱和拆箱的原理</h3><p>自动装箱时编译器调用valueOf将原始类型值转换成对象，同时自动拆箱时，编译器通过调用类似intValue(),doubleValue()这类的方法将对象转换成原始类型值。明白自动装箱和拆箱的原理后，我们带着上面的疑问进行分析下Integer的自动装箱的实现源码。如下：</p>
<p>​        <img src= "/img/loading.gif" data-lazy-src="/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/content3.png" class title="content3"><br>        <img src= "/img/loading.gif" data-lazy-src="/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/content4.png" class title="content4"></p>
<p>Integer i1 = 40; 自动装箱，相当于调用了Integer.valueOf(40);方法。首先判断i值是否在-128和127之间，如果在-128和127之间则直接从IntegerCache.cache缓存中获取指定数字的包装类；不存在则new出一个新的包装类。</p>
<p>IntegerCache内部实现了一个Integer的静态常量数组，在类加载的时候，执行static静态块进行初始化-128到127之间的Integer对象，存放到cache数组中。cache属于常量，存放在java的方法区中。 </p>
<p>接着看下面是java8种基本类型的自动装箱代码实现。如下：</p>

<img src= "/img/loading.gif" data-lazy-src="/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/content6.png" class title="content6">
<p>通过分析源码发现，只有double和float的自动装箱代码没有使用缓存，每次都是new 新的对象，其它的6种基本类型都使用了缓存策略。<br>使用缓存策略是因为，缓存的这些对象都是经常使用到的（如字符、-128至127之间的数字），防止每次自动装箱都创建一次对象的实例。<br>而double、float是浮点型的，没有特别的热的（经常使用到的）数据的，缓存效果没有其它几种类型使用效率高。<br>下面在看下装箱和拆箱问题解惑。</p>
<img src= "/img/loading.gif" data-lazy-src="/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/content7.png" class title="content7">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
