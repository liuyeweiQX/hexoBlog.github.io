<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>仟寻</title>
  <icon>https://www.gravatar.com/avatar/2f40a7c42c405207c58b2f1aad190f39</icon>
  <subtitle>个人博客</subtitle>
  <link href="http://www.liuyewei.com/atom.xml" rel="self"/>
  
  <link href="http://www.liuyewei.com/"/>
  <updated>2020-10-08T17:21:39.698Z</updated>
  <id>http://www.liuyewei.com/</id>
  
  <author>
    <name>liuyewei</name>
    <email>769489912@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解JVM--3.垃圾收集与内存分配</title>
    <link href="http://www.liuyewei.com/2020/10/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>http://www.liuyewei.com/2020/10/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</id>
    <published>2020-10-08T17:04:30.000Z</published>
    <updated>2020-10-08T17:21:39.698Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>垃圾收集(Garbage Collection，简称GC)思考？</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？<br>了解垃圾收集和内存分配的意义？<br>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。<br>Java各区域区别？</li></ul><ol><li><strong>程序计数器、虚拟机栈、本地方法栈</strong>3个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的(尽管在运行期会由即时编译器进行一些优化，但在基于概念模型的讨论里，大体上可以认为是编译期可知的)，因此这几个区域的内存分配和回收都具备确定性， 在这几个区域内就<strong>不需要过多考虑如何回收的问题</strong>，当方法结束或者线程结束时，内存自然就跟随着回收了。      </li><li><strong>堆和方法区</strong>这两个区域则有着很显著的不确定性:一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器<strong>所关注的正是这部分内存该如何管理</strong>。</li></ol><h3 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p><strong>引用计数算法</strong>(Reference Counting)：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一;当引用失效时，计数器值就减一;任何时刻计数器为零的对象就是不可能再被使用的<br>引用计数算法虽然占用了一些额外的内存空间来进行计数，但它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。<br>在Java领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。<br>举个简单的例子，对象objA和objB都有字段instance，赋值令 objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。      </p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>当前主流的商用程序语言(Java、C#，上溯至前面提到的古老的Lisp)的内存管理子系统，都是通过<strong>可达性分析</strong>(Reachability Analysis)算法来判定对象是否存活的。这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。<br>例：对象object5、object6、object7虽然互有关联，但是它们到GC Roots是不可达的，因此它们将会被判定为可回收的对象      </p><img src= "/img/loading.gif" data-lazy-src="/2020/10/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/content1.png" class title="content1"><p>在Java技术体系里面，固定可作为GC Roots的对象包括以下几种: </p><ul><li>在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。 </li><li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。 </li><li>在方法区中常量引用的对象，譬如字符串常量池(String Table)里的引用。      </li><li>在本地方法栈中JNI(即通常所说的Native方法)引用的对象。 </li><li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象(比如NullPointExcepiton、OutOfMemoryError)等，还有系统类加载器。 </li><li>所有被同步锁(synchronized关键字)持有的对象。</li><li>反映Java虚拟机内部情况的JM XBean、JVM TI中注册的回调、本地代码缓存等。<br>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。譬如分代收集和局部回收(Partial GC)，如果只针对Java堆中某一块区域发起垃圾收集时(如最典型的只针对新生代的垃圾收集)，必须考虑到内存区域是虚拟机自己的实现细节(在用户视角里任何内存区域都是不可见的)，更不是孤立封闭的，所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引用，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确性。</li></ul><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>引用定义： 如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用。<br>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为<strong>强引用</strong>(Strongly Reference)、<strong>软引用</strong>(Soft Reference)、<strong>弱引用</strong>(Weak Reference)和<strong>虚引用</strong>(Phantom Reference)4种，这4种引用强度依次逐渐减弱。 </p><ul><li>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。 </li><li>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</li><li>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。 </li><li>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了PhantomReference类来实现虚引用。</li></ul><h4 id="回收前的finalize"><a href="#回收前的finalize" class="headerlink" title="回收前的finalize()"></a>回收前的finalize()</h4><p>要真正回收一个对象，至少要经历<strong>两次标记</strong>过程:如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。<br>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为<strong>F-Queue的队列</strong>之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的<strong>Finalizer线程</strong>去执行它们的finalize()方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。 这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。<strong>finalize()方法是对象逃脱死亡命运的最后一次机会</strong>，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对 象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 (this关键字)赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合;如果对象这时候还没有逃脱，那基本上它就真的要被回收了。      </p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p><strong>方法区的垃圾收集主要回收两部分内容:废弃的常量和不再使用的类型</strong>。<br><strong>回收废弃常量</strong>：举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类(接口)、方法、字段的符号引用也与此类似。<br><strong>回收类型</strong>: </p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 </li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。 </li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。<br>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。      </li></ul><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><p>当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”(Generational Collection)的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上:<br>1)弱分代假说(Weak Generational Hypothesis):绝大多数对象都是朝生夕灭的。<br>2)强分代假说(Strong Generational Hypothesis):熬过越多次垃圾收集过程的对象就越难以消亡。<br>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则:收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄(年龄即对象熬过垃圾收集过程的次数)分配到不同的区域之中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间;如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。<br>把分代收集理论具体放到现在的商用Java虚拟机里，设计者一般至少会把Java堆划分为<strong>新生代</strong>(Young Generation)和<strong>老年代</strong>(Old Generation)两个区域。顾名思义，在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。      </p><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>最早出现也是最基础的垃圾收集算法是“标记-清除”(Mark-Sweep)算法。<br>算法分为“标记”和“清除”两个阶段:首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程。<br>它的主要缺点有两个:第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低;第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><img src= "/img/loading.gif" data-lazy-src="/2020/10/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/content2.png" class title="content2"><h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>标记-复制算法常被简称为复制算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一点。</p><img src= "/img/loading.gif" data-lazy-src="/2020/10/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/content3.png" class title="content3"><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以针对老年代对象的存亡特征，另外一种有针对性的“标记-整理”(Mark-Compact)算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。<br>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策：</p><img src= "/img/loading.gif" data-lazy-src="/2020/10/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/content4.png" class title="content4">]]></content>
    
    
    <summary type="html">垃圾收集(Garbage Collection，简称GC)思考</summary>
    
    
    
    <category term="深入理解JVM" scheme="http://www.liuyewei.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/"/>
    
    
    <category term="JVM" scheme="http://www.liuyewei.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM--2.内存区域与内存溢出</title>
    <link href="http://www.liuyewei.com/2020/09/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--2.%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    <id>http://www.liuyewei.com/2020/09/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--2.%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</id>
    <published>2020-09-27T16:50:30.000Z</published>
    <updated>2020-09-27T17:42:50.993Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>C与C++程序开发中，在内存管理领域中，开发人员即拥有每一个对象的“所有权”，又担负着每一个对象生命从开始到终结的维护责任。<br>Java程序开发中，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题。但是，一出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误、修正问题将成为一项异常艰难的工作。<br>Java优势：<strong>内存动态分配；垃圾收集技术</strong>。</p><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p><img src= "/img/loading.gif" data-lazy-src="/2020/09/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--2.%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/content1.png" class title="content1"><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。<br>由于<strong>Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的</strong>，在任何一个确定的时刻，一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“<strong>线程私有</strong>”的内存。<br>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址;如果正在执行的是本地(Native)方法，这个计数器值则应为空(Undefined)。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。      </p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>与程序计数器一样，Java虚拟机栈(Java Virtual Machine Stack)也是<strong>线程私有</strong>的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型:每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br><strong>局部变量表</strong>存放了编译期可知的各种Java虚拟机基本数据类型(boolean、byte、char、short、int、 float、long、double)、对象引用(reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)。<br>这些数据类型在局部变量表中的存储空间以<strong>局部变量槽</strong>(Slot)来表示，其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。请读者注意，这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间(譬如按照1个变量槽占用32个比特、64个比特，或者更多)来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。<br>在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况:<strong>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常;如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常</strong>。      </p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>本地方法栈(Native Method Stacks)与虚拟机栈所发挥的作用是非常相似的，<strong>其区别只是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的本地(Native)方法服务</strong>。<br>《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机(譬如Hot-Spot虚拟机)直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。      </p><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>对于Java应用程序来说，Java堆(Java Heap)是<strong>虚拟机所管理的内存中最大的一块</strong>。Java堆是被所有<strong>线程共享</strong>的一块内存区域，在虚拟机启动时创建。此内存区域的<strong>唯一目的就是存放对象实例</strong>，Java世界里“几乎”所有的对象实例都在这里分配内存。<br>Java堆是<strong>垃圾收集器管理的内存区域</strong>，因此一些资料中它也被称作“GC堆”(Garbage Collected Heap)。从回收内存的角度看，由于现代垃圾收集器大部分都是基于<strong>分代收集理论</strong>设计的，所以Java堆中经常会出现“新生代”“老年代”“永久代”“Eden空间”“From Survivor空间”“To Survivor空间”等名词。<br>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 (Thread Local Allocation Buffer，TLAB)，以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。<br>根据《Java虚拟机规范》的规定，Java堆可以<strong>处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的</strong>，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象(典型的如数组对象)，多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。<br>Java堆既<strong>可以被实现成固定大小的，也可以是可扩展的</strong>，不过当前主流的Java虚拟机都是按照可扩展来实现的(通过参数-Xmx和-Xms设定)。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。   </p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区(Method Area)与Java堆一样，是各个<strong>线程共享</strong>的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”(Non-Heap)，目的是与Java堆区分开来。<br>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。      </p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><strong>运行时常量池(Runtime Constant Pool)是方法区的一部分</strong>。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是<strong>常量池表</strong>(Constant Pool Table)，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。<br>Java虚拟机对于Class文件每一部分(自然也包括常量池)的格式都有严格规定，如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池，《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。<br>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。<br>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p><strong>直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分</strong>，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。<br>在JDK 1.4中新加入了NIO(New Input/Output)类，引入了一种<strong>基于通道(Channel)与缓冲区 (Buffer)的I/O方式</strong>，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。<br>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存(包括物理内存、SWAP分区或者分页文件)大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制)，从而导致动态扩展时出现OutOfMemoryError异常。      </p><h3 id="HotSpot虚拟机"><a href="#HotSpot虚拟机" class="headerlink" title="HotSpot虚拟机"></a>HotSpot虚拟机</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><ol><li>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程      </li><li>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。      </li><li>接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码(实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算)、对象的GC分代年龄等信息。这些信息存放在对象的对象头(Object Header)之中。      </li><li>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始——构造函数，即Class文件中的&lt;init&gt;()方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说(由字节码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此)，new指令之后会接着执行&lt;init&gt;()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。  </li></ol><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分:<strong>对象头</strong>(Header)、<strong>实例数据</strong>(Instance Data)和<strong>对齐填充</strong>(Padding)。      </p><ol><li>HotSpot虚拟机对象的对象头部分包括两类信息。第一类是用于存储对象自身的<strong>运行时数据</strong>，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机(未开启压缩指针)中分别为32个比特和64个比特，官方称它 为“Mark Word”。对象头的另外一部分是<strong>类型指针</strong>，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，      </li><li>接下来实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。      </li><li>对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。  </li></ol><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>主流的访问方式主要有<strong>使用句柄</strong>和<strong>直接指针</strong>两种:      </p><ol><li><p>如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。 </p><img src= "/img/loading.gif" data-lazy-src="/2020/09/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--2.%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/content2.png" class title="content2"></li><li><p>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。   </p><img src= "/img/loading.gif" data-lazy-src="/2020/09/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--2.%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/content3.png" class title="content3"></li></ol><p>优势：</p><ul><li>使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</li><li>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。   </li></ul>]]></content>
    
    
    <summary type="html">Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域</summary>
    
    
    
    <category term="深入理解JVM" scheme="http://www.liuyewei.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/"/>
    
    
    <category term="JVM" scheme="http://www.liuyewei.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM--1.走近Java</title>
    <link href="http://www.liuyewei.com/2020/09/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--1.%E8%B5%B0%E8%BF%91Java/"/>
    <id>http://www.liuyewei.com/2020/09/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM--1.%E8%B5%B0%E8%BF%91Java/</id>
    <published>2020-09-27T15:36:44.000Z</published>
    <updated>2020-09-27T17:33:39.979Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java不仅仅是一门编程语言，它还是一个由一系列计算机软件和规范组成的技术体系，这个技术体系提供了完整的用于软件开发和跨平台部署的支持环境，并广泛应用于嵌入式系统、移动终端、企业服务器、大型机等多种场合。<br>Java优势：</p><ul><li>结构严谨、面向对象</li><li>摆脱硬件平台的束缚，实现“一次编写、到处运行“</li><li>提供相对安全的内存管理和访问机制，避免绝大部分内存泄漏和指针越界问题</li><li>实现了热点代码检测和运行时编译及优化，使得Java应用能随着运行时间的增长而获得更高的性能</li><li>有一套完善的应用程序接口，还有无数来自商业机构和开源社区的第三方类库来帮助用户实现各种各样的功能</li></ul><h3 id="Java技术体系"><a href="#Java技术体系" class="headerlink" title="Java技术体系"></a>Java技术体系</h3><p>组成部分：</p><ol><li>Java程序设计语言</li><li>各种硬件平台上的Java虚拟机实现</li><li>Class文件格式</li><li>Java类库API</li><li>来自商业机构和开源社区的第三方Java类库<br>Java程序设计语言、Java虚拟机、Java类库这三部分统称为<strong>JDK（Java Development Kit），JDK是用于支持Java程序开发的最小环境</strong>。<br>Java类库API中的Java SE API子集和Java虚拟机这两部分统称为<strong>JRE（Java Runtime Environment），JRE是支持Java程序运行的标准环境</strong>。</li></ol><p>产品线：</p><ol><li>Java Card：支持Java小程序（Applets）运行在小内存设备（如智能卡）上的平台。</li><li>Java ME(Micro Edition)：支持Java程序运行在移动终端（手机、PDA）上的平台。JDK 6以前被称为J2ME。备注：智能手机上Java开发的Android应用不属于Java ME。</li><li>Java SE(Standard Edition)：支持面向桌面级应用（如Windows下的应用程序）的Java平台。JDK 6以前被称为J2SE。</li><li>Java EE(Enterprise Edition)：支持使用多层架构的企业应用（如ERP、MIS、CRM应用）的Java平台。JDK 6以前被称为J2EE，在JDK 10以后被Oracle放弃，捐献给Eclipse基金会管理，此后被称为Jakarta EE。</li></ol>]]></content>
    
    
    <summary type="html">Java不仅仅是一门编程语言，它还是一个由一系列计算机软件和规范组成的技术体系</summary>
    
    
    
    <category term="深入理解JVM" scheme="http://www.liuyewei.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/"/>
    
    
    <category term="JVM" scheme="http://www.liuyewei.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Gulp压缩和PWA</title>
    <link href="http://www.liuyewei.com/2020/09/08/Gulp%E5%8E%8B%E7%BC%A9%E5%92%8CPWA/"/>
    <id>http://www.liuyewei.com/2020/09/08/Gulp%E5%8E%8B%E7%BC%A9%E5%92%8CPWA/</id>
    <published>2020-09-08T15:53:30.000Z</published>
    <updated>2020-09-09T15:15:39.194Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Gulp压缩"><a href="#Gulp压缩" class="headerlink" title="Gulp压缩"></a>Gulp压缩</h3><p>Gulp是一款自动化构建的工具</p><h4 id="安装Gulp"><a href="#安装Gulp" class="headerlink" title="安装Gulp"></a>安装Gulp</h4><p>npm install –global gulp-cli<br>安装过程中若报权限错误，则执行sudo npm install –global gulp-cli命令</p><h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><ul><li>HTML压缩插件：<br>npm install gulp-htmlclean –save-dev<br>npm install –save gulp-htmlmin</li><li>CSS压缩插件：<br>npm install gulp-clean-css –save-dev</li><li>JS压缩插件：（二选一）<br>terser 是 ES6+ 的 JavaScript 解析器<br>gulp-babel 是一个 JavaScript 转换编译器，可以把 ES6 转换成 ES5<ul><li>npm install –save-dev gulp-uglify  ;  npm install terser</li><li>npm install –save-dev gulp-uglify  ;  npm install –save-dev gulp-babel @babel/core @babel/preset-env</li></ul></li><li>图片压缩插件：<br>npm install –save-dev gulp-imagemin</li></ul><h4 id="创建gulpfile-js文件"><a href="#创建gulpfile-js文件" class="headerlink" title="创建gulpfile.js文件"></a>创建gulpfile.js文件</h4><p>在 Hexo 的根目录，创建 gulpfile.js 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">const gulp &#x3D; require(&quot;gulp&quot;);</span><br><span class="line">const workbox &#x3D; require(&quot;workbox-build&quot;);</span><br><span class="line">const cleanCSS &#x3D; require(&#39;gulp-clean-css&#39;);</span><br><span class="line">const htmlmin &#x3D; require(&#39;gulp-htmlmin&#39;);</span><br><span class="line">const htmlclean &#x3D; require(&#39;gulp-htmlclean&#39;);</span><br><span class="line">const imagemin &#x3D; require(&#39;gulp-imagemin&#39;);</span><br><span class="line">&#x2F;&#x2F; tester (如果使用tester,把下面4行前面的&#x2F;&#x2F;去掉)</span><br><span class="line">&#x2F;&#x2F; const uglifyjs &#x3D; require(&#39;terser&#39;);</span><br><span class="line">&#x2F;&#x2F; const composer &#x3D; require(&#39;gulp-uglify&#x2F;composer&#39;);</span><br><span class="line">&#x2F;&#x2F; const pump &#x3D; require(&#39;pump&#39;);</span><br><span class="line">&#x2F;&#x2F; const minify &#x3D; composer(uglifyjs, console);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; babel (如果不是使用bebel,把下面兩行註釋掉)</span><br><span class="line">const uglify &#x3D; require(&#39;gulp-uglify&#39;)</span><br><span class="line">const babel &#x3D; require(&#39;gulp-babel&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; minify js - babel（ 如果不是使用bebel,把下面註釋掉）</span><br><span class="line">gulp.task(&#39;compress&#39;, () &#x3D;&gt;</span><br><span class="line">    gulp.src([&#39;.&#x2F;public&#x2F;**&#x2F;*.js&#39;, &#39;!.&#x2F;public&#x2F;**&#x2F;*.min.js&#39;])</span><br><span class="line">        .pipe(babel(&#123;</span><br><span class="line">            presets: [&#39;@babel&#x2F;preset-env&#39;]</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(uglify().on(&#39;error&#39;, function (e) &#123;</span><br><span class="line">            console.log(e)</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&#39;.&#x2F;public&#39;))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; minify js - tester (如果使用tester,把下面前面的&#x2F;&#x2F;去掉)</span><br><span class="line">&#x2F;&#x2F; gulp.task(&#39;compress&#39;, function (cb) &#123;</span><br><span class="line">&#x2F;&#x2F;   const options &#x3D; &#123;&#125;;</span><br><span class="line">&#x2F;&#x2F;   pump([</span><br><span class="line">&#x2F;&#x2F;     gulp.src([&#39;.&#x2F;public&#x2F;**&#x2F;*.js&#39;, &#39;!.&#x2F;public&#x2F;**&#x2F;*.min.js&#39;]),</span><br><span class="line">&#x2F;&#x2F;     minify(options),</span><br><span class="line">&#x2F;&#x2F;     gulp.dest(&#39;.&#x2F;public&#39;)</span><br><span class="line">&#x2F;&#x2F;   ],</span><br><span class="line">&#x2F;&#x2F;   cb</span><br><span class="line">&#x2F;&#x2F;   );</span><br><span class="line">&#x2F;&#x2F; &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; css</span><br><span class="line">gulp.task(&#39;minify-css&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    return gulp.src(&#39;.&#x2F;public&#x2F;**&#x2F;*.css&#39;)</span><br><span class="line">        .pipe(cleanCSS(&#123;</span><br><span class="line">            compatibility: &#39;ie11&#39;</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&#39;.&#x2F;public&#39;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 壓縮 public 目錄內 html</span><br><span class="line">gulp.task(&#39;minify-html&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    return gulp.src(&#39;.&#x2F;public&#x2F;**&#x2F;*.html&#39;)</span><br><span class="line">        .pipe(htmlclean())</span><br><span class="line">        .pipe(htmlmin(&#123;</span><br><span class="line">            removeComments: true, &#x2F;&#x2F; 清除 HTML 註釋</span><br><span class="line">            collapseWhitespace: true, &#x2F;&#x2F; 壓縮 HTML</span><br><span class="line">            collapseBooleanAttributes: true, &#x2F;&#x2F; 省略布爾屬性的值 &lt;input checked&#x3D;&quot;true&quot;&#x2F;&gt; &#x3D;&#x3D;&gt; &lt;input &#x2F;&gt;</span><br><span class="line">            removeEmptyAttributes: true, &#x2F;&#x2F; 刪除所有空格作屬性值 &lt;input id&#x3D;&quot;&quot; &#x2F;&gt; &#x3D;&#x3D;&gt; &lt;input &#x2F;&gt;</span><br><span class="line">            removeScriptTypeAttributes: true, &#x2F;&#x2F; 刪除 &lt;script&gt; 的 type&#x3D;&quot;text&#x2F;javascript&quot;</span><br><span class="line">            removeStyleLinkTypeAttributes: true, &#x2F;&#x2F; 刪除 &lt;style&gt; 和 &lt;link&gt; 的 type&#x3D;&quot;text&#x2F;css&quot;</span><br><span class="line">            minifyJS: true, &#x2F;&#x2F; 壓縮頁面 JS</span><br><span class="line">            minifyCSS: true, &#x2F;&#x2F; 壓縮頁面 CSS</span><br><span class="line">            minifyURLs: true</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&#39;.&#x2F;public&#39;))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 压缩 public&#x2F;uploads 目录内图片</span><br><span class="line">gulp.task(&#39;minify-images&#39;, async () &#x3D;&gt; &#123;</span><br><span class="line">    gulp.src(&#39;.&#x2F;public&#x2F;img&#x2F;**&#x2F;*.*&#39;)</span><br><span class="line">        .pipe(imagemin(&#123;</span><br><span class="line">            optimizationLevel: 5, &#x2F;&#x2F;类型：Number  预设：3  取值範围：0-7（优化等级）</span><br><span class="line">            progressive: true, &#x2F;&#x2F;类型：Boolean 预设：false 无失真压缩jpg图片</span><br><span class="line">            interlaced: false, &#x2F;&#x2F;类型：Boolean 预设：false 隔行扫描gif进行渲染</span><br><span class="line">            multipass: false, &#x2F;&#x2F;类型：Boolean 预设：false 多次优化svg直到完全优化</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&#39;.&#x2F;public&#x2F;img&#39;));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(&#39;generate-service-worker&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    return workbox.injectManifest(&#123;</span><br><span class="line">        swSrc: &#39;.&#x2F;sw-template.js&#39;,</span><br><span class="line">        swDest: &#39;.&#x2F;public&#x2F;sw.js&#39;,</span><br><span class="line">        globDirectory: &#39;.&#x2F;public&#39;,</span><br><span class="line">        globPatterns: [</span><br><span class="line">            &quot;**&#x2F;*.&#123;html,css,js,json,woff2&#125;&quot;</span><br><span class="line">        ],</span><br><span class="line">        modifyURLPrefix: &#123;</span><br><span class="line">            &quot;&quot;: &quot;.&#x2F;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 執行 gulp 命令時執行的任務</span><br><span class="line">gulp.task(&quot;default&quot;, gulp.series(&quot;generate-service-worker&quot;, gulp.parallel(</span><br><span class="line">    &#39;compress&#39;,&#39;minify-html&#39;, &#39;minify-css&#39;, &#39;minify-images&#39;</span><br><span class="line">)));</span><br></pre></td></tr></table></figure><p>注意： 如果有使用到 Butterfly 主题提供的 mermaid 标签，那需要把 52 行.pipe(htmlclean()) 注释掉，同时，把 55 行的 collapseWhitespace: true, 改为 false</p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>在hexo g之后运行gulp</p><h3 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h3><p>渐进式网络应用程式（英语：Progressive Web Apps，简称：PWA）是一种普通网页或网站架构起来的网络应用程式，但它可以以传统应用程式或原生移动应用程式形式展示给用户。这种应用程式形态视图将目前最为现代化的浏览器提供的功能与行动装置的体验优势相结合。</p><p>当你的网站实现了 PWA，那就代表了:</p><ul><li>用户可以添加你的博客到电脑╱手机的桌面，以原生应用般的方式浏览你的博客</li><li>用户可以更快速地浏览你的博客</li><li>用户可以离线浏览你的博客</li></ul><p>使用 Service Worker。我们使用 Workbox 这个工具生成 sw.js 以快速实现 Service Worker ，并实现页面的预缓存和页面更新后的提醒功能。</p><h4 id="开启设置和配置manifest-json"><a href="#开启设置和配置manifest-json" class="headerlink" title="开启设置和配置manifest.json"></a>开启设置和配置manifest.json</h4><p>主题配置文件中开启pwa选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwa:</span><br><span class="line">  enable: true</span><br><span class="line">  manifest: &#x2F;img&#x2F;pwa&#x2F;manifest.json</span><br><span class="line">  apple_touch_icon: &#x2F;img&#x2F;pwa&#x2F;apple-touch-icon.png</span><br><span class="line">  favicon_32_32: &#x2F;img&#x2F;pwa&#x2F;32.png</span><br><span class="line">  favicon_16_16: &#x2F;img&#x2F;pwa&#x2F;16.png</span><br><span class="line">  mask_icon: &#x2F;img&#x2F;pwa&#x2F;safari-pinned-tab.svg</span><br></pre></td></tr></table></figure><h4 id="在主题的source-目录中创建-manifest-json-文件。"><a href="#在主题的source-目录中创建-manifest-json-文件。" class="headerlink" title="在主题的source 目录中创建 manifest.json 文件。"></a>在主题的source 目录中创建 manifest.json 文件。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;string&quot;, &#x2F;&#x2F;应用全称</span><br><span class="line">    &quot;short_name&quot;: &quot;Junzhou&quot;, &#x2F;&#x2F;应用简称</span><br><span class="line">    &quot;theme_color&quot;: &quot;#49b1f5&quot;, &#x2F;&#x2F;匹配浏览器的地址栏颜色</span><br><span class="line">    &quot;background_color&quot;: &quot;#49b1f5&quot;,&#x2F;&#x2F;加载应用时的背景色</span><br><span class="line">    &quot;display&quot;: &quot;standalone&quot;,&#x2F;&#x2F;首选显示模式 其他选项有：fullscreen,minimal-ui,browser</span><br><span class="line">    &quot;scope&quot;: &quot;&#x2F;&quot;,</span><br><span class="line">    &quot;start_url&quot;: &quot;&#x2F;&quot;,</span><br><span class="line">    &quot;icons&quot;: [ &#x2F;&#x2F;该数组指定icons图标参数，用来时适配不同设备（需为png，至少包含一个192px*192px的图标）</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;src&quot;: &quot;images&#x2F;pwaicons&#x2F;36.png&quot;, &#x2F;&#x2F;图标文件的目录，需在source&#x2F;目录下自行创建。</span><br><span class="line">          &quot;sizes&quot;: &quot;36x36&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image&#x2F;png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;src&quot;: &quot;images&#x2F;pwaicons&#x2F;48.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;48x48&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image&#x2F;png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;src&quot;: &quot;images&#x2F;pwaicons&#x2F;72.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;72x72&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image&#x2F;png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;src&quot;: &quot;images&#x2F;pwaicons&#x2F;96.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;96x96&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image&#x2F;png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;src&quot;: &quot;images&#x2F;pwaicons&#x2F;144.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;144x144&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image&#x2F;png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;src&quot;: &quot;images&#x2F;pwaicons&#x2F;192.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;192x192&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image&#x2F;png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;src&quot;: &quot;images&#x2F;pwaicons&#x2F;512.png&quot;,</span><br><span class="line">            &quot;sizes&quot;: &quot;512x512&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;image&#x2F;png&quot;</span><br><span class="line">          &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;splash_pages&quot;: null &#x2F;&#x2F;配置自定义启动动画。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="安装插件："><a href="#安装插件：" class="headerlink" title="安装插件："></a>安装插件：</h4><p>npm install workbox-build gulp –save-dev</p><h4 id="创建gulpfile-js文件（见上文）"><a href="#创建gulpfile-js文件（见上文）" class="headerlink" title="创建gulpfile.js文件（见上文）"></a>创建gulpfile.js文件（见上文）</h4><h4 id="在-Hexo-的根目录，创建一个-sw-template-js-文件"><a href="#在-Hexo-的根目录，创建一个-sw-template-js-文件" class="headerlink" title="在 Hexo 的根目录，创建一个 sw-template.js 文件"></a>在 Hexo 的根目录，创建一个 sw-template.js 文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">const workboxVersion &#x3D; &#39;5.1.3&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">importScripts(&#96;https:&#x2F;&#x2F;storage.googleapis.com&#x2F;workbox-cdn&#x2F;releases&#x2F;$&#123;workboxVersion&#125;&#x2F;workbox-sw.js&#96;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">workbox.core.setCacheNameDetails(&#123;</span><br><span class="line">    prefix: &quot;your name&quot;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">workbox.core.skipWaiting();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">workbox.core.clientsClaim();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">workbox.precaching.precacheAndRoute(self.__WB_MANIFEST,&#123;</span><br><span class="line">    directoryIndex: null</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">workbox.precaching.cleanupOutdatedCaches();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Images</span><br><span class="line">workbox.routing.registerRoute(</span><br><span class="line">    &#x2F;\.(?:png|jpg|jpeg|gif|bmp|webp|svg|ico)$&#x2F;,</span><br><span class="line">    new workbox.strategies.CacheFirst(&#123;</span><br><span class="line">        cacheName: &quot;images&quot;,</span><br><span class="line">        plugins: [</span><br><span class="line">            new workbox.expiration.ExpirationPlugin(&#123;</span><br><span class="line">                maxEntries: 1000,</span><br><span class="line">                maxAgeSeconds: 60 * 60 * 24 * 30</span><br><span class="line">            &#125;),</span><br><span class="line">            new workbox.cacheableResponse.CacheableResponsePlugin(&#123;</span><br><span class="line">                statuses: [0, 200]</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Fonts</span><br><span class="line">workbox.routing.registerRoute(</span><br><span class="line">    &#x2F;\.(?:eot|ttf|woff|woff2)$&#x2F;,</span><br><span class="line">    new workbox.strategies.CacheFirst(&#123;</span><br><span class="line">        cacheName: &quot;fonts&quot;,</span><br><span class="line">        plugins: [</span><br><span class="line">            new workbox.expiration.ExpirationPlugin(&#123;</span><br><span class="line">                maxEntries: 1000,</span><br><span class="line">                maxAgeSeconds: 60 * 60 * 24 * 30</span><br><span class="line">            &#125;),</span><br><span class="line">            new workbox.cacheableResponse.CacheableResponsePlugin(&#123;</span><br><span class="line">                statuses: [0, 200]</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Google Fonts</span><br><span class="line">workbox.routing.registerRoute(</span><br><span class="line">    &#x2F;^https:\&#x2F;\&#x2F;fonts\.googleapis\.com&#x2F;,</span><br><span class="line">    new workbox.strategies.StaleWhileRevalidate(&#123;</span><br><span class="line">        cacheName: &quot;google-fonts-stylesheets&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line">workbox.routing.registerRoute(</span><br><span class="line">    &#x2F;^https:\&#x2F;\&#x2F;fonts\.gstatic\.com&#x2F;,</span><br><span class="line">    new workbox.strategies.CacheFirst(&#123;</span><br><span class="line">        cacheName: &#39;google-fonts-webfonts&#39;,</span><br><span class="line">        plugins: [</span><br><span class="line">            new workbox.expiration.ExpirationPlugin(&#123;</span><br><span class="line">                maxEntries: 1000,</span><br><span class="line">                maxAgeSeconds: 60 * 60 * 24 * 30</span><br><span class="line">            &#125;),</span><br><span class="line">            new workbox.cacheableResponse.CacheableResponsePlugin(&#123;</span><br><span class="line">                statuses: [0, 200]</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Static Libraries</span><br><span class="line">workbox.routing.registerRoute(</span><br><span class="line">    &#x2F;^https:\&#x2F;\&#x2F;cdn\.jsdelivr\.net&#x2F;,</span><br><span class="line">    new workbox.strategies.CacheFirst(&#123;</span><br><span class="line">        cacheName: &quot;static-libs&quot;,</span><br><span class="line">        plugins: [</span><br><span class="line">            new workbox.expiration.ExpirationPlugin(&#123;</span><br><span class="line">                maxEntries: 1000,</span><br><span class="line">                maxAgeSeconds: 60 * 60 * 24 * 30</span><br><span class="line">            &#125;),</span><br><span class="line">            new workbox.cacheableResponse.CacheableResponsePlugin(&#123;</span><br><span class="line">                statuses: [0, 200]</span><br><span class="line">            &#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line">workbox.googleAnalytics.initialize();</span><br></pre></td></tr></table></figure><h4 id="在主题配置文件中，添加需要的-css-和-js"><a href="#在主题配置文件中，添加需要的-css-和-js" class="headerlink" title="在主题配置文件中，添加需要的 css 和 js"></a>在主题配置文件中，添加需要的 css 和 js</h4><pre><code>inject:  head:    - &#39;&lt;style type=&quot;text/css&quot;&gt;.app-refresh&#123;position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease&#125;.app-refresh-wrap&#123;display:flex;color:#fff;height:100%;align-items:center;justify-content:center&#125;.app-refresh-wrap a&#123;color:#fff;text-decoration:underline;cursor:pointer&#125;&lt;/style&gt;&#39;  bottom:    - &#39;&lt;div class=&quot;app-refresh&quot; id=&quot;app-refresh&quot;&gt; &lt;div class=&quot;app-refresh-wrap&quot;&gt; &lt;label&gt;✨ 网站已更新最新版本 👉&lt;/label&gt; &lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;location.reload()&quot;&gt;点击刷新&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;function showNotification()&#123;if(GLOBAL_CONFIG.Snackbar)&#123;var t=&quot;light&quot;===document.documentElement.getAttribute(&quot;data-theme&quot;)?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show(&#123;text:&quot;已更新最新版本&quot;,backgroundColor:t,duration:5e5,pos:e,actionText:&quot;点击刷新&quot;,actionTextColor:&quot;#fff&quot;,onActionClick:function(t)&#123;location.reload()&#125;&#125;)&#125;else&#123;var o=`top: 0; background: $&#123;&quot;light&quot;===document.documentElement.getAttribute(&quot;data-theme&quot;)?&quot;#49b1f5&quot;:&quot;#1f1f1f&quot;&#125;;`;document.getElementById(&quot;app-refresh&quot;).style.cssText=o&#125;&#125;&quot;serviceWorker&quot;in navigator&amp;&amp;(navigator.serviceWorker.controller&amp;&amp;navigator.serviceWorker.addEventListener(&quot;controllerchange&quot;,function()&#123;showNotification()&#125;),window.addEventListener(&quot;load&quot;,function()&#123;navigator.serviceWorker.register(&quot;/sw.js&quot;)&#125;));&lt;/script&gt;&#39;</code></pre><p><strong>重点：配置了这些，可能会出现很多问题，本人尝试后有取消了这些配置，谨慎对待，学习学习就好</strong>                                                                                                                                               </p>]]></content>
    
    
    <summary type="html">Gulp压缩和PWA</summary>
    
    
    
    <category term="Hexo" scheme="http://www.liuyewei.com/categories/Hexo/"/>
    
    
    <category term="优化" scheme="http://www.liuyewei.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Spring基础</title>
    <link href="http://www.liuyewei.com/2020/08/26/Spring%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.liuyewei.com/2020/08/26/Spring%E5%9F%BA%E7%A1%80/</id>
    <published>2020-08-25T16:32:20.000Z</published>
    <updated>2020-09-07T13:51:00.514Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Spring框架？Spring框架有哪些主要模块？"><a href="#什么是Spring框架？Spring框架有哪些主要模块？" class="headerlink" title="什么是Spring框架？Spring框架有哪些主要模块？"></a>什么是Spring框架？Spring框架有哪些主要模块？</h3><p>Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的。<br>Spring框架至今已集成了20多个模块。这些模块主要被分为核心容器、数据访问、集成、web、AOP（面向切面编程）、工具、消息和测试模块。</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content1.png" class title="content1"><h3 id="使用Spring框架能带来的哪些好处？"><a href="#使用Spring框架能带来的哪些好处？" class="headerlink" title="使用Spring框架能带来的哪些好处？"></a>使用Spring框架能带来的哪些好处？</h3><ul><li>Dependency Injection(DI)方法使得构造器和JavaBean properties文件中的依赖关系一目了然。  </li><li>与EJB容器相比较，IoC容器更加趋向于轻量级。这样一来IoC容器在有限的内存和CPU资源的情况下进行应用程序的开发和发布就变得十分有利。</li><li>Spring并没有闭门造车，Spring利用了已有的技术比如ORM框架、logging框架、J2EE、Quartz和JDK Timer，以及其他视图技术。</li><li>Spring框架是按照模块的形式来组织的。由包和类的编号就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。</li><li>要测试一项Spring开发的应用程序十分简单，因为测试相关的环境代码都已经囊括在框架中了。更加简单的是，利用JavaBean形式的POJO类，可以很方便的利用依赖注入来写入测试数据。</li><li>Spring的Web框架亦是一个精心设计的Web MVC框架，为开发者们在Web框架的选择上提供了一个除了主流框架比如Struts、过度设计的、不流行web框架的以外的有力选项。</li><li>Spring提供了一个便捷的事务管理接口，适用于小型的本地事物处理（比如在单DB的环境下）和复杂的共同事物处理（比如利用JTA的复杂DB环境）</li></ul><h3 id="什么是控制反转（IOC）？什么是依赖注入？"><a href="#什么是控制反转（IOC）？什么是依赖注入？" class="headerlink" title="什么是控制反转（IOC）？什么是依赖注入？"></a>什么是控制反转（IOC）？什么是依赖注入？</h3><p>控制反转是应用于软件工程领域中的，在运行时被装配器对象来绑定耦合对象的一种编程技巧，对象之间耦合关系在编译时通常是未知的。在传统的编程方式中，业务逻辑的流程是由应用程序中的早已被设定好关联关系的对象来决定的，该对象关系图由装配器负责实例化，这种实现方式还可以将对象之间的关联关系的定义抽象化。而绑定的过程是通过“依赖注入”实现的。<br>控制反转是一种以给予应用程序中目标组件更多控制为目的设计范式，并在我们的实际工作中起到了有效地作用。<br>依赖注入是编译阶段尚未知所需的功能是来自哪个的类的情况下，将其他对象所依赖的功能对象实例化的模式。这就需要一种机制用来激活相应的组件以提供特定的功能，所以依赖注入是控制反转的基础。否则如果在组件不受框架控制的情况下，框架又怎么知道要创建哪个组件？<br>在Java依赖注入有以下三种实现方式：</p><ol><li>构造器注入</li><li>Setter方法注入</li><li>接口注入</li></ol><h3 id="解释Spring框架中的IoC？"><a href="#解释Spring框架中的IoC？" class="headerlink" title="解释Spring框架中的IoC？"></a>解释Spring框架中的IoC？</h3><p>Spring中的org.springframework.beans包和org.springframework.context包构成了Spring框架IoC容器的基础。<br>BeanFactory接口提供了一个先进的配置机制，使得任何类型的对象的配置成为可能。ApplicationContext接口对BeanFactory（是一个子接口）进行了扩展，在BeanFactory的基础上添加了其他功能，比如与Spring的AOP更容易继承，也提供了处理message resource的机制（用于国际化）、事件传播以及应用层的特别配置，比如针对Web应用的WebApplicationContext。<br>Org.springframework.beans.factory.BeanFactory是Spring IoC容器的具体实现，用来包装和管理前面提到的各种bean。BeanFactory接口是Spring IoC容器的核心接口。</p><h3 id="BeanFactory和ApplicationContext有什么区别？"><a href="#BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="BeanFactory和ApplicationContext有什么区别？"></a>BeanFactory和ApplicationContext有什么区别？</h3><p>BeanFactory可以理解为含有bean集合的工厂类。BeanFactory包含了种bean的定义，以便在接受客户端请求时将对应的bean实例化。<br>BeanFactory还能再实例化对象时生成协作类之间的关系。此举将bean自身与bean客户端的配置中解放出来。BeanFactory还包含了bean生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。<br>从表面上看，application context如同bean factory一样具有bean定义、bean关联关系的设置，根据请求分发bean的功能。但application context在此基础上还提供了其他的功能。</p><ol><li>提供了支持国际化的文本消息</li><li>统一的资源文件读取方式</li><li>已在监听器中注册的bean的事件</li></ol><p>以下是三种较为常见的ApplicationContext实现方式：<br>1、ClassPathXmlApplicationContext：从classpath的XML配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content2.png" class title="content2"><p>2、FileSystemXmlApplicationContext：由文件系统中的XML配置文件读取上下文</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content3.png" class title="content3"><p>3、XmlWebApplicationContext：由Web应用的XML文件读取上下文</p><h3 id="Spring有几种配置方式"><a href="#Spring有几种配置方式" class="headerlink" title="Spring有几种配置方式"></a>Spring有几种配置方式</h3><p>将Spring配置到应用开发中有以下三种方式：</p><ol><li>基于XML的配置</li><li>基于注解的配置</li><li>基于Java的配置</li></ol><h3 id="如何用基于XML配置的方式配置Spring？"><a href="#如何用基于XML配置的方式配置Spring？" class="headerlink" title="如何用基于XML配置的方式配置Spring？"></a>如何用基于XML配置的方式配置Spring？</h3><p>在Spring框架中，依赖和服务需要在专门的配置文件来实现，我常用的XML格式的配置文件。这些配置文件的格式通常用<beans>开头，然后一系列的bean定义和专门的应用配置选项组成。<br>SpringXML配置的主要目的时候是使所有的Spring组件都可以用xml文件的形式来进行配置。这意味着不会出现其他的Spring配置类型（比如声明的方式或基于Java Class的配置方式）<br>Spring的XML配置方式是使用被Spring命名空间的所支持的一系列的XML标签来实现的。Spring有以下主要的命名空间：context、beans、jdbc、tx、aop、mvc和aso。</beans></p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content4.png" class title="content4"><p>下面这个web.xml仅仅配置了DispatcherServlet，这件最简单的配置便能满足应用程序配置运行时组件的需求。</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content5.png" class title="content5"><h3 id="如何用基于Java配置的方式配置Spring？"><a href="#如何用基于Java配置的方式配置Spring？" class="headerlink" title="如何用基于Java配置的方式配置Spring？"></a>如何用基于Java配置的方式配置Spring？</h3><p>Spring对Java配置的支持是由@Configuration注解和@Bean注解来实现的。由@Bean注解的方法将会实例化、配置和初始化一个新对象，这个对象将由Spring的IoC容器来管理。@Bean声明所起到的作用与<bean> 元素类似。被@Configuration所注解的类则表示这个类的主要目的是作为bean定义的资源。被@Configuration声明的类可以通过在同一个类的内部调用@bean方法来设置嵌入bean的依赖关系。<br>最简单的@Configuration 声明类请参考下面的代码：</bean></p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content6.png" class title="content6"><p>对于上面的@Beans配置文件相同的XML配置文件如下：</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content7.png" class title="content7"><p>上述配置方式的实例化方式如下：利用AnnotationConfigApplicationContext 类进行实例化</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content8.png" class title="content8"><p>要使用组件组建扫描，仅需用@Configuration进行注解即可：</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content9.png" class title="content9"><p>在上面的例子中，com.acme包首先会被扫到，然后再容器内查找被@Component 声明的类，找到后将这些类按照Sring bean定义进行注册。<br>如果你要在你的web应用开发中选用上述的配置的方式的话，需要用AnnotationConfigWebApplicationContext 类来读取配置文件，可以用来配置Spring的Servlet监听器ContrextLoaderListener或者Spring MVC的DispatcherServlet。</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content10.png" class title="content10"><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content11.png" class title="content11"><h3 id="怎样用注解的方式配置Spring？"><a href="#怎样用注解的方式配置Spring？" class="headerlink" title="怎样用注解的方式配置Spring？"></a>怎样用注解的方式配置Spring？</h3><p>Spring在2.5版本以后开始支持用注解的方式来配置依赖注入。可以用注解的方式来替代XML方式的bean描述，可以将bean描述转移到组件类的内部，只需要在相关类上、方法上或者字段声明上使用注解即可。注解注入将会被容器在XML注入之前被处理，所以后者会覆盖掉前者对于同一个属性的处理结果。<br>注解装配在Spring中是默认关闭的。所以需要在Spring文件中配置一下才能使用基于注解的装配模式。如果你想要在你的应用程序中使用关于注解的方法的话，请参考如下的配置</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content12.png" class title="content12"><p>在<code> &lt;context:annotation-config/&gt;</code>标签配置完成以后，就可以用注解的方式在Spring中向属性、方法和构造方法中自动装配变量。<br>下面是几种比较重要的注解类型：</p><ul><li>@Required：该注解应用于设值方法。  </li><li>@Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。  </li><li>@Qualifier：该注解和@Autowired注解搭配使用，用于消除特定bean自动装配的歧义。</li><li>JSR-250 Annotations：Spring支持基于JSR-250 注解的以下注解，@Resource、@PostConstruct 和@PreDestroy。</li></ul><h3 id="请解释Spring-Bean的生命周期？"><a href="#请解释Spring-Bean的生命周期？" class="headerlink" title="请解释Spring Bean的生命周期？"></a>请解释Spring Bean的生命周期？</h3><p>Spring Bean的生命周期简单易懂。在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不在被调用时需要进行相关的析构操作，并从bean容器中移除。<br>Spring bean factory 负责管理在spring容器中被创建的bean的生命周期。Bean的生命周期由两组回调（call back）方法组成。</p><ul><li>初始化之后调用的回调方法。  </li><li>销毁之前调用的回调方法。<br>Spring框架提供了以下四种方式来管理bean的生命周期事件：  </li><li>InitializingBean和DisposableBean回调接口</li><li>针对特殊行为的其他Aware接口  </li><li>Bean配置文件中的Custom init()方法和destroy()方法  </li><li>@PostConstruct和@PreDestroy注解方式<br>使用customInit()和 customDestroy()方法管理bean生命周期的代码样例如下：<img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content36.png" class title="content36"></li></ul><h3 id="Spring-Bean的作用域之间有什么区别？"><a href="#Spring-Bean的作用域之间有什么区别？" class="headerlink" title="Spring Bean的作用域之间有什么区别？"></a>Spring Bean的作用域之间有什么区别？</h3><p>Spring容器中的bean可以分为5个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下：</p><ul><li>singleton：这种bean范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个bean的实例，单例的模式由bean factory自身来维护。</li><li>prototype：原形范围与单例范围相反，为每一个bean请求提供一个实例。</li><li>request：在请求bean范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。</li><li>Session：与请求范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</li><li>global-session：global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。<br>全局作用域与Servlet中的session作用域效果相同。</li></ul><h3 id="什么是Spring-inner-beans？"><a href="#什么是Spring-inner-beans？" class="headerlink" title="什么是Spring inner beans？"></a>什么是Spring inner beans？</h3><p>在Spring框架中，无论何时bean被使用时，当仅被调用了一个属性。一个明智的做法是将这个bean声明为内部bean。内部bean可以用setter注入“属性”和构造方法注入“构造参数”的方式来实现。<br>比如，在我们的应用程序中，一个Customer类引用了一个Person类，我们的要做的是创建一个Person的实例，然后在Customer内部使用。</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content13.png" class title="content13"><p>内部bean的声明方式如下：</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content14.png" class title="content14"><h3 id="Spring框架中的单例Beans是线程安全的吗？"><a href="#Spring框架中的单例Beans是线程安全的吗？" class="headerlink" title="Spring框架中的单例Beans是线程安全的吗？"></a>Spring框架中的单例Beans是线程安全的吗？</h3><p>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。但实际上，大部分的Spring bean并没有可变的状态(比如Serview类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。如果你的bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。<br>最浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。</p><h3 id="请举例说明如何在Spring中注入一个Java-Collection？"><a href="#请举例说明如何在Spring中注入一个Java-Collection？" class="headerlink" title="请举例说明如何在Spring中注入一个Java Collection？"></a>请举例说明如何在Spring中注入一个Java Collection？</h3><p>Spring提供了以下四种集合类的配置元素：</p><ul><li><list> : 该标签用来装配可重复的list值。</list></li><li><set> : 该标签用来装配没有重复的set值。</set></li><li><map>: 该标签可用来注入键和值可以为任何类型的键值对。</map></li><li><props> : 该标签支持注入键和值都是字符串类型的键值对。<br>下面看一下具体的例子：<img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content15.png" class title="content15"><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content16.png" class title="content16"></props></li></ul><h3 id="如何向Spring-Bean中注入一个Java-util-Properties？"><a href="#如何向Spring-Bean中注入一个Java-util-Properties？" class="headerlink" title="如何向Spring Bean中注入一个Java.util.Properties？"></a>如何向Spring Bean中注入一个Java.util.Properties？</h3><p>第一种方法是使用如下面代码所示的<props> 标签：</props></p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content17.png" class title="content17"><p>也可用”util:”命名空间来从properties文件中创建出一个propertiesbean，然后利用setter方法注入bean的引用。</p><h3 id="请解释Spring-Bean的自动装配？"><a href="#请解释Spring-Bean的自动装配？" class="headerlink" title="请解释Spring Bean的自动装配？"></a>请解释Spring Bean的自动装配？</h3><p>在Spring框架中，在配置文件中设定bean的依赖关系是一个很好的机制，Spring容器还可以自动装配合作关系bean之间的关联关系。这意味着Spring可以通过向Bean Factory中注入的方式自动搞定bean之间的依赖关系。自动装配可以设置在每个bean上，也可以设定在特定的bean上。<br>下面的XML配置文件表明了如何根据名称将一个bean设置为自动装配：</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content18.png" class title="content18"><p>除了bean配置文件中提供的自动装配模式，还可以使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在按照如下的配置方式在Spring配置文件进行配置才可以使用。</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content19.png" class title="content19"><p>也可以通过在配置文件中配置AutowiredAnnotationBeanPostProcessor 达到相同的效果。</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content20.png" class title="content20"><p>配置好以后就可以使用@Autowired来标注了。</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content21.png" class title="content21"><h3 id="请解释自动装配模式的区别？"><a href="#请解释自动装配模式的区别？" class="headerlink" title="请解释自动装配模式的区别？"></a>请解释自动装配模式的区别？</h3><p>在Spring框架中共有5种自动装配，让我们逐一分析。</p><ul><li>no：这是Spring框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在bean定义中用标签明确的设置依赖关系。  </li><li>byName：该选项可以根据bean名称设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的名称自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。</li><li>byType：该选项可以根据bean类型设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的类型自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。</li><li>constructor：造器的自动装配和byType模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。</li><li>autodetect：该模式自动探测使用构造器自动装配或者byType自动装配。首先，首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在bean内部没有找到相应的构造器或者是无参构造器，容器就会自动选择byTpe的自动装配方式。</li></ul><h3 id="如何开启基于注解的自动装配？"><a href="#如何开启基于注解的自动装配？" class="headerlink" title="如何开启基于注解的自动装配？"></a>如何开启基于注解的自动装配？</h3><p>要使用 @Autowired，需要注册 AutowiredAnnotationBeanPostProcessor，可以有以下两种方式来实现：<br>1、引入配置文件中的<bean>下引入<code>&lt;context:annotation-config&gt;</code></bean></p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content22.png" class title="content22"><p>2、在bean配置文件中直接引入AutowiredAnnotationBeanPostProcessor</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content23.png" class title="content23"><h3 id="请举例解释-Required-annotation？"><a href="#请举例解释-Required-annotation？" class="headerlink" title="请举例解释@Required annotation？"></a>请举例解释@Required annotation？</h3><p>在产品级别的应用中，IoC容器可能声明了数十万了bean，bean与bean之间有着复杂的依赖关系。设值注解方法的短板之一就是验证所有的属性是否被注解是一项十分困难的操作。可以通过在<bean>中设置“dependency-check”来解决这个问题。<br>在应用程序的生命周期中，你可能不大愿意花时间在验证所有bean的属性是否按照上下文文件正确配置。或者你宁可验证某个bean的特定属性是否被正确的设置。即使是用“dependency-check”属性也不能很好的解决这个问题，在这种情况下，你需要使用@Required 注解。<br>需要用如下的方式使用来标明bean的设值方法。</bean></p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content24.png" class title="content24"><p>RequiredAnnotationBeanPostProcessor是Spring中的后置处理用来验证被@Required 注解的bean属性是否被正确的设置了。在使用RequiredAnnotationBeanPostProcesso来验证bean属性之前，首先要在IoC容器中对其进行注册：</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content25.png" class title="content25"><p>但是如果没有属性被用 @Required 注解过的话，后置处理器会抛出一个BeanInitializationException 异常。</p><h3 id="请举例解释-Autowired注解"><a href="#请举例解释-Autowired注解" class="headerlink" title="请举例解释@Autowired注解?"></a>请举例解释@Autowired注解?</h3><p>@Autowired注解对自动装配何时何处被实现提供了更多细粒度的控制。@Autowired注解可以像@Required注解、构造器一样被用于在bean的设值方法上自动装配bean的属性，一个参数或者带有任意名称或带有多个参数的方法。<br>比如，可以在设值方法上使用@Autowired注解来替代配置文件中的 <property>元素。当Spring容器在setter方法上找到@Autowired注解时，会尝试用byType 自动装配。<br>当然我们也可以在构造方法上使用@Autowired 注解。带有@Autowired 注解的构造方法意味着在创建一个bean时将会被自动装配，即便在配置文件中使用<constructor-arg> 元素。</constructor-arg></property></p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content26.png" class title="content26"><p>下面是没有构造参数的配置方式：</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content27.png" class title="content27"><h3 id="请举例说明-Qualifier注解？"><a href="#请举例说明-Qualifier注解？" class="headerlink" title="请举例说明@Qualifier注解？"></a>请举例说明@Qualifier注解？</h3><p>@Qualifier注解意味着可以在被标注bean的字段上可以自动装配。Qualifier注解可以用来取消Spring不能取消的bean应用。<br>下面的示例将会在Customer的person属性中自动装配person的值。</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content28.png" class title="content28"><p>下面我们要在配置文件中来配置Person类。</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content29.png" class title="content29"><p>Spring会知道要自动装配哪个person bean么？不会的，但是运行上面的示例时，会抛出下面的异常：</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content30.png" class title="content30"><p>要解决上面的问题，需要使用 @Quanlifier注解来告诉Spring容器要装配哪个bean：</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content31.png" class title="content31"><h3 id="构造方法注入和设值注入有什么区别？"><a href="#构造方法注入和设值注入有什么区别？" class="headerlink" title="构造方法注入和设值注入有什么区别？"></a>构造方法注入和设值注入有什么区别？</h3><p>请注意以下明显的区别：</p><ul><li>在设值注入方法支持大部分的依赖注入，如果我们仅需要注入int、string和long型的变量，我们不要用设值的方法注入。对于基本类型，如果我们没有注入的话，可以为基本类型设置默认值。在构造方法注入不支持大部分的依赖注入，因为在调用构造方法中必须传入正确的构造参数，否则的话为报错。</li><li>设值注入不会重写构造方法的值。如果我们对同一个变量同时使用了构造方法注入又使用了设置方法注入的话，那么构造方法将不能覆盖由设值方法注入的值。很明显，因为构造方法尽在对象被创建时调用。  </li><li>在使用设值注入时有可能还不能保证某种依赖是否已经被注入，也就是说这时对象的依赖关系有可能是不完整的。而在另一种情况下，构造器注入则不允许生成依赖关系不完整的对象。</li><li>在设值注入时如果对象A和对象B互相依赖，在创建对象A时Spring会抛出sObjectCurrentlyInCreationException异常，因为在B对象被创建之前A对象是不能被创建的，反之亦然。所以Spring用设值注入的方法解决了循环依赖的问题，因对象的设值方法是在对象被创建之前被调用的。</li></ul><h3 id="Spring框架中有哪些不同类型的事件？"><a href="#Spring框架中有哪些不同类型的事件？" class="headerlink" title="Spring框架中有哪些不同类型的事件？"></a>Spring框架中有哪些不同类型的事件？</h3><p>Spring的ApplicationContext 提供了支持事件和代码中监听器的功能。<br>我们可以创建bean用来监听在ApplicationContext 中发布的事件。ApplicationEvent类和在ApplicationContext接口中处理的事件，如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content32.png" class title="content32"><p>Spring 提供了以下5中标准的事件：</p><ul><li>上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext      接口中的refresh()方法时被触发。  </li><li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。</li><li>上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。</li><li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</li><li>请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。<br>除了上面介绍的事件以外，还可以通过扩展ApplicationEvent 类来开发自定义的事件。<img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content33.png" class title="content33">为了监听这个事件，还需要创建一个监听器：<img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content34.png" class title="content34">之后通过applicationContext接口的publishEvent()方法来发布自定义事件。<img src= "/img/loading.gif" data-lazy-src="/2020/08/26/Spring%E5%9F%BA%E7%A1%80/content35.png" class title="content35"></li></ul><h3 id="FileSystemResource和ClassPathResource有何区别？"><a href="#FileSystemResource和ClassPathResource有何区别？" class="headerlink" title="FileSystemResource和ClassPathResource有何区别？"></a>FileSystemResource和ClassPathResource有何区别？</h3><p>在FileSystemResource 中需要给出spring-config.xml文件在你项目中的相对路径或者绝对路径。在ClassPathResource中spring会在ClassPath中自动搜寻配置文件，所以要把ClassPathResource 文件放在ClassPath下。<br>如果将spring-config.xml保存在了src文件夹下的话，只需给出配置文件的名称即可，因为src文件夹是默认。<br>简而言之，ClassPathResource在环境变量中读取配置文件，FileSystemResource在配置文件中读取配置文件。</p><h3 id="Spring框架中都用到了哪些设计模式？"><a href="#Spring框架中都用到了哪些设计模式？" class="headerlink" title="Spring框架中都用到了哪些设计模式？"></a>Spring框架中都用到了哪些设计模式？</h3><p>Spring框架中使用到了大量的设计模式，下面列举了比较有代表性的：</p><ul><li>代理模式—在AOP和remoting中被用的比较多。  </li><li>单例模式—在spring配置文件中定义的bean默认为单例模式。</li><li>模板方法—用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</li><li>前端控制器—Srping提供了DispatcherServlet来对请求进行分发。</li><li>视图帮助(View Helper )—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。</li><li>依赖注入—贯穿于BeanFactory / ApplicationContext接口的核心理念。</li><li>工厂模式—BeanFactory用来创建对象的实例。 </li></ul>]]></content>
    
    
    <summary type="html">Spring基础</summary>
    
    
    
    <category term="Java进阶" scheme="http://www.liuyewei.com/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Spring" scheme="http://www.liuyewei.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>类的加载过程</title>
    <link href="http://www.liuyewei.com/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>http://www.liuyewei.com/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</id>
    <published>2020-08-20T14:25:30.000Z</published>
    <updated>2020-09-07T13:47:06.358Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java-类加载机制"><a href="#Java-类加载机制" class="headerlink" title="Java 类加载机制"></a>Java 类加载机制</h3><p>类从被加载到JVM中开始，到卸载为止，整个生命周期包括：<strong>加载、验证、准备、解析、初始化、使用和卸载七个阶段</strong>。<br>其中类加载过程包括加载、验证、准备、解析和初始化五个阶段。</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/content1.png" class title="content1"><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol><li>通过类加载器，加载.class文件到内存中。</li><li>将读取到.classs数据存储到运行时内存区的方法区。</li><li>然后将其转换为一个与目标类型对应的java.lang.Class对象实例。这个Class对象在日后就会作为方法区中该类的各种数据的访问入口。</li></ol><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>确保被加载的类（.class文件的字节流），是否按照java虚拟的规范。不会造成安全问题</p><ol><li>文件格式验证:<br>第一阶段要验证字节流是否符合 Class文件格式的规范, 井且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：</li></ol><ul><li>是否以魔数 0xCAFEBABE开头</li><li>主、次版本号是否在当前虚拟机处理范围之内。</li><li>常量池的常量中是否有不被支持的常量类型(检査常量tag 标志)。</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合装型的常量。</li><li>CONSTANT_Utf8_info型的常量中是否有不符合 UTF8编码的数据</li><li>Class 文件中各个部分及文件本身是否有被删除的或附加的其他信息 实际上第一阶段的验证点还远不止这些, 这是其中的一部分。只有通过了这个阶段的验证之后, 字节流才会进入内存的方法区中进行存储, 所以后面的三个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。</li></ul><ol start="2"><li>元数据验证<br>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求,这个阶段可能包括的验证点如下:</li></ol><ul><li>这个类是否有父类(除了java.lang.object之外,所有的类都应当有父类)</li><li>这个类的父类是否继承了不允许被继承的类(被finaI修饰的类)<br>如果这个类不是抽象类, 是否实現了其父类或接口之中要求实现的所有方法类中的字段、方法是否与父类产生了矛盾(例如覆盖了父类的final字段, 或者出現不符合规则的方法重载, 例如方法参数都一致, 但返回值类型却不同等) 第二阶段的验证点同样远不止这些，这一阶段的主要目的是对类的元数据信息进行语义检验, 保证不存在不符合 Java语言规范的元数据信息。</li></ul><ol start="3"><li>字节码验证<br>第三阶段是整个验证过程中最复杂的一个阶段, 主要目的是通过数据流和控制流的分析，确定语义是合法的。符号逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如：</li></ol><ul><li>保证任意时刻操作数栈的数据装型与指令代码序列都能配合工作, 例如不会出现类似这样的情况:在操作栈中放置了一个 int类型的数据, 使用时却按long类型来加载入本地变量表中。</li><li>保证跳转指令不会跳转到方法体以外的字节码指令上</li><li>保证方法体中的类型转换是有效的, 例如可以把一个子类对象赋值给父类数据装型，这是安全的,但是把父类对象意赋值给子类数据类型,甚至把对象赋值给与它毫无继承关系、 完全不相干的一个数据类型, 则是危险和不合法的。 即使一个方法体通过了字节码验证, 也不能说明其一定就是安全的。</li></ul><ol start="4"><li>符号引用验证<br>最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候, 这个转化动作将在连接的第三个阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外(常量池中的各种符号引用) 的信息进行匹配性的校验, 通常需要校验以下内容:</li></ol><ul><li>符号引用中通过字将串描述的全限定名是否能找到对应的类</li><li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段 。</li><li>符号引用中的类、字段和方法的访问性(private、 protected、 public、 default)是否可被当前     类访问</li><li>符号引用验证的目的是确保解析动作能正常执行, 如果无法通过符号引用验证, 将会抛出一个java.lang.IncompatibleClassChangError异常的子类, 如 java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。</li></ul><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>主要是为类变量（注意，不是实例变量）分配内存，并且赋予初值，此时的赋值是Java虚拟机根据不同变量类型的默认初始值：<br>如8种基本类型的初值，默认为0；引用类型的初值则为null；常量的初值即为代码中设置的值<br> 1、final static temp = 100，此时temp就是赋值 100。<br> 2、String temp = “123456”，此时temp值就是null。<br> 3、int temp = 100，此时temp值就是0。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>将类的二进制数据中的符号引用替换成直接引用（符号引用是用一组符号描述所引用的目标；直接引用是指向目标的指针）<br>可以认为是一些静态绑定的会被解析，动态绑定则只会在运行时进行解析；静态绑定包括一些final方法(不可以重写),static方法(只会属于当前类)，构造器(不会被重写)<br>在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化，则是为标记为常量值的字段赋值的过程。<br>换句话说，只对static修饰的变量或语句块进行初始化。<br>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。<br>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</p><h3 id="涉及问题"><a href="#涉及问题" class="headerlink" title="涉及问题"></a>涉及问题</h3><p>一个类的构造器，代码块，静态代码块，成员变量的的执行顺序。</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/content2.png" class title="content2"><img src= "/img/loading.gif" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/content3.png" class title="content3"><img src= "/img/loading.gif" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/content4.png" class title="content4">                                                                                                                                                   ]]></content>
    
    
    <summary type="html">类的加载过程</summary>
    
    
    
    <category term="Java" scheme="http://www.liuyewei.com/categories/Java/"/>
    
    
    <category term="类" scheme="http://www.liuyewei.com/tags/%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>类的加载方式</title>
    <link href="http://www.liuyewei.com/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.liuyewei.com/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/</id>
    <published>2020-08-20T14:11:30.000Z</published>
    <updated>2020-09-07T13:47:06.362Z</updated>
    
    <content type="html"><![CDATA[<h3 id="加载方式"><a href="#加载方式" class="headerlink" title="加载方式"></a>加载方式</h3><ol><li>隐式加载：new</li><li>显式加载：ClassLoader.loadClass和Class.forName</li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>方式1：<br>new通过关键字 然后通过不同的构造器直接创建实例。如：new String() ，new String(“test”)</p><p>方式2：<br>需要加载.class文件获取Class对象，通过Class对象，获取构造器，然后调用newInstance方法创建对象实例。</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/content1.png" class title="content1"><h3 id="ClassLoader-loadClass和Class-forName的区别"><a href="#ClassLoader-loadClass和Class-forName的区别" class="headerlink" title="ClassLoader.loadClass和Class.forName的区别"></a>ClassLoader.loadClass和Class.forName的区别</h3><p>Class的装载包括3个步骤：加载（loading），连接（link），初始化（initialize）<br>参考：类的加载过程文档</p><p><strong>Class.forName:</strong></p><img src= "/img/loading.gif" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/content2.png" class title="content2"><p>forName0第二个参数initialize初始化 这里参数是true说明是初始化过的，因此，静态代码块和静态变量是会被执行和初始化的<br><strong>ClassLoader.loadClass:</strong>  </p><img src= "/img/loading.gif" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/content3.png" class title="content3"><p>第二参数resolve，注释中说明这个参数代表是否链接（类加载过程中的链接过程）ClassLoader.loadClass在加载类的过程中只走了第一步</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><img src= "/img/loading.gif" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/content4.png" class title="content4"><img src= "/img/loading.gif" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/content5.png" class title="content5"><img src= "/img/loading.gif" data-lazy-src="/2020/08/20/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/content6.png" class title="content6"><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Class.forName得到的class是已经初始化<br>ClassLoader.loadeClass得到的class是还没有链接的</p>]]></content>
    
    
    <summary type="html">类的加载方式</summary>
    
    
    
    <category term="Java" scheme="http://www.liuyewei.com/categories/Java/"/>
    
    
    <category term="类" scheme="http://www.liuyewei.com/tags/%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>唯一索引和非唯一索引</title>
    <link href="http://www.liuyewei.com/2020/08/12/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95/"/>
    <id>http://www.liuyewei.com/2020/08/12/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95/</id>
    <published>2020-08-11T16:25:30.000Z</published>
    <updated>2020-09-07T13:50:12.407Z</updated>
    
    <content type="html"><![CDATA[<p>非唯一索引也叫普通索引</p><p>如果在一个列上同时建唯一索引和普通索引的话，mysql 会自动选择唯一索引 唯一索引和普通索引使用的结构都是 B-tree，执行时间复杂度都是 O(log n)</p><h3 id="普通索引（非唯一索引）"><a href="#普通索引（非唯一索引）" class="headerlink" title="普通索引（非唯一索引）"></a>普通索引（非唯一索引）</h3><p>普通索引（由关键字 KEY 或 INDEX 定义的索引）的唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（WHERE column =）或排序条件（ORDER BY column）中的数据列创建索引。只要有可能，就应该选择一个数据最整齐、最紧凑的数据列（如一个整数类型的数据列）来创建索引。</p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>普通索引允许被索引的数据列包含重复的值</p><p>如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字 UNIQUE 把它定义为一个唯一索引。这么做的好处：一是简化了 MySQL 对这个索引的管理工作，这个索引也因此而变得更有效率（区分度：distinct * / count (*) 高）；二是 MySQL 会在有新记录插入数据表时，自动检查新记录的这个字段的值是否已经在某个记录的这个字段里出现过了；如果是，MySQL 将拒绝插入那条新记录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。</p><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>主键索引是唯一索引的特殊类型</p><p>数据库表通常有一列或列组合，其值用来唯一标识表中的每一行。该列称为表的主键 在数据库关系图中为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的。当在查询中使用主键索引时，它还允许快速访问数据 </p><p>它们的一些比较： </p><ol><li><p>对于主键 MySQL 会自动建立唯一索引；</p></li><li><p>主键不一定只包含一个字段，所以可以在主键的其中一个字段建唯一索引； </p></li><li><p>主键可作外键，唯一索引不可；</p></li><li><p>主键不可为空，唯一索引可； </p></li><li><p>主键也可是多个字段的组合； </p></li></ol><p>主键与唯一索引不同的是： </p><ol><li><p>有not null属性； </p></li><li><p>每个表只能有一个。</p></li></ol>]]></content>
    
    
    <summary type="html">唯一索引和非唯一索引</summary>
    
    
    
    <category term="数据库" scheme="http://www.liuyewei.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://www.liuyewei.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>JPA</title>
    <link href="http://www.liuyewei.com/2020/08/12/JPA/"/>
    <id>http://www.liuyewei.com/2020/08/12/JPA/</id>
    <published>2020-08-11T16:10:30.000Z</published>
    <updated>2020-09-07T13:51:16.172Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JPA是什么"><a href="#JPA是什么" class="headerlink" title="JPA是什么"></a>JPA是什么</h3><p>JPA（Java Persistence API）Java持久化API。是一套sun公司Java官方制定的ORM方案，是规范，是标准，sun公司自己并没有实现。</p><p><strong>关键点：ORM，标准 概念(关键字)</strong></p><h3 id="ORM是什么"><a href="#ORM是什么" class="headerlink" title="ORM是什么"></a>ORM是什么</h3><p>ORM（Object Relational Mapping）对象关系映射。问：ORM有什么用？在操作数据库之前，先把数据表与实体类关联起来。然后通过实体类的对象操作（增删改查）数据库表，这个就是ORM的行为！所以：ORM是一个实现使用对象操作数据库的设计思想！通过这句话，我们知道JPA的作用就是通过对象操作数据库的，不用编写sql语句。</p><h3 id="JPA的实现者"><a href="#JPA的实现者" class="headerlink" title="JPA的实现者"></a>JPA的实现者</h3><p>既然我们说JPA是一套标准，意味着，它只是一套实现ORM理论的接口。没有实现的代码。那么我们必须要有具体实现者才可以完成ORM操作功能的实现！ </p><p>市场上主流的JPA框架（实现者）有：Hibernate(JBoss)、EclipseTop(Eclipse社区)、OpenJPA(Apache基金会)其中Hibernate是众多实现者之中，性能最好的。</p><h3 id="JPA的作用是什么"><a href="#JPA的作用是什么" class="headerlink" title="JPA的作用是什么"></a>JPA的作用是什么</h3><p>JPA是ORM的一套标准，既然JPA为ORM而生，那么JPA的作用就是实现使用对象操作数据库，不用写SQL</p><p>数据库是用sql操作的，那用对象操作，由谁来产生SQL?</p><p>答：JPA实现框架</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li><p>实体（pojo）表示关系数据库中的一个表</p></li><li><p>每个实体实例对应着该表中的一行</p></li><li><p>类必须用javax.persistence.Entity注解</p></li><li><p>类必须含有一个public或者protected的无参构造函数</p></li><li><p>当实体实例被当做值以分离对象的方式进行传递（例如通过会话bean的远程业务接口）则该类必须实现Serializable（序列化）接口</p></li><li><p>唯一的对象标志符，简单主键（javax.persistence.Id），复合主键（javax.persistence.EmbeddledId和javax.persistence.IdClass）</p></li></ul><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul><li><p>一对一：@OneToOne</p></li><li><p>一对多：@OneToMany</p></li><li><p>多对一：@ManyToOne</p></li><li><p>多对多：@ManyToMany</p></li></ul><h3 id="EntityManager"><a href="#EntityManager" class="headerlink" title="EntityManager"></a>EntityManager</h3><ul><li><p>管理实体的一个类，接口</p></li><li><p>定义与持久性上下文进行交互的方法</p></li><li><p>创建和删除持久实体类，通过实体的主键查找实体</p></li><li><p>允许在实体类上进行查询</p></li></ul>]]></content>
    
    
    <summary type="html">JPA</summary>
    
    
    
    <category term="框架" scheme="http://www.liuyewei.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="JPA" scheme="http://www.liuyewei.com/tags/JPA/"/>
    
  </entry>
  
  <entry>
    <title>消息队列</title>
    <link href="http://www.liuyewei.com/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>http://www.liuyewei.com/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</id>
    <published>2020-08-04T15:46:15.000Z</published>
    <updated>2020-09-07T13:48:57.866Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h3><p>可以把消息队列比作是一个存放消息的容器。消息队列是分布式系统中重要的组件，使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性。目前使用较多的消息队列有ActiveMQ，RabbitMQ，Kafka，RocketMQ。</p><p>另外，队列Queue是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。比如生产者发送消息1,2,3…对于消费者就会按照1,2,3…的顺序来消费。但是偶尔也会出现消息被消费的顺序不对的情况，比如某个消息消费失败又或者一个queue多个consumer也会导致消息被消费的顺序不对，我们一定要保证消息被消费的顺序正确。</p><p>除了上面说的消息消费顺序的问题，使用消息队列，还要考虑如何保证消息不被重复消费？如何保证消息的可靠性传输（如何处理消息丢失的问题）？……等等问题。所以说使用消息队列也不是十全十美的，使用它也会让系统可用性降低、复杂度提高，另外需要我们保障一致性等问题。</p><h3 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h3><p>使用消息队列主要有两点好处：</p><ol><li>通过异步处理提高系统性能（削峰、减少响应所需时间）；</li><li>降低系统耦合性。</li></ol><p><strong>（1）通过异步处理提高系统性能（削峰、减少响应所需时间)</strong></p><img src= "/img/loading.gif" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content1.png" class title="消息队列1"><p>如上图，<strong>在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求发送给消息队列之后立即返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善</strong>。</p><p>通过以上分析可以得出<strong>消息队列具有很好的削峰作用的功能——即通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务</strong>。举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content2.png" class title="content2"><p>因为<strong>用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败</strong>。因此使用消息队列进行异步处理之后，需要<strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p><p><strong>（2）降低系统耦合性</strong><br>如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。<br>最常见的<strong>事件驱动架构</strong>类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。如下图所示：</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content3.png" class title="content3"><p><strong>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接收者（消费者）订阅消息</strong>。从上图可以看到<strong>消息发送者（生产者）和消息接收者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接收者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。<br>消息接收者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p><p><strong>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息</strong>。</p><p><strong>备注</strong>：不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。<strong>除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式</strong>。另外，这两者消息模型是JMS提供的，AMQP协议还提供了5种消息模型。</p><h3 id="使用消息队列带来的一些问题"><a href="#使用消息队列带来的一些问题" class="headerlink" title="使用消息队列带来的一些问题"></a>使用消息队列带来的一些问题</h3><ul><li>系统可用性降低：系统可用性在某种程度上降低，在加入MQ之前，不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后就需要去考虑了！</li><li>系统复杂性提高：加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li>一致性问题：上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了！</li></ul><h3 id="JMS-VS-AMQP"><a href="#JMS-VS-AMQP" class="headerlink" title="JMS VS AMQP"></a>JMS VS AMQP</h3><h4 id="JMS简介"><a href="#JMS简介" class="headerlink" title="JMS简介"></a>JMS简介</h4><p>JMS（JAVA Message Service，java消息服务）是Java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。<strong>JMS API是一个消息服务的标准或者说是规范</strong>，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。<br><strong>ActiveMQ就是基于JMS规范实现的</strong>。</p><h4 id="JMS两种消息模型"><a href="#JMS两种消息模型" class="headerlink" title="JMS两种消息模型"></a>JMS两种消息模型</h4><ol><li><p>点到点（P2P）模型</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content4.png" class title="content4"><p>使用<strong>队列（Queue）</strong>作为消息通信载体；满足<strong>生产者与消费者模式</strong>，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：生产者发送100条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费）</p></li><li><p>发布/订阅（Pub/Sub）模型</p><img src= "/img/loading.gif" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content5.png" class title="content5"><p>发布订阅模型（Pub/Sub）使用<strong>主题（Topic）</strong>作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p></li></ol><h4 id="JMS五种不同的消息正文格式"><a href="#JMS五种不同的消息正文格式" class="headerlink" title="JMS五种不同的消息正文格式"></a>JMS五种不同的消息正文格式</h4><p>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有的消息格式的一些级别的兼容性。</p><ul><li>StreamMessage – Java原始值的数据流</li><li>MapMessage – 一套名称-值对</li><li>TextMessage – 一套字符串对象</li><li>ObjectMessage – 一个序列化的Java对象</li><li>BytesMessage – 一个字节的数据流</li></ul><h4 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h4><p>AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准<strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。<br><strong>RabbitMQ就是基于AMQP协议实现的。</strong></p><img src= "/img/loading.gif" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content6.png" class title="content6"><p><strong>总结：</strong></p><ul><li>AMQP为消息定义了线路层（wire-level protocol）的协议，而JMS所定义的是API规范。在Java体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而AMQP天然具有跨平台、跨语言特性</li><li>JMS 支持TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）</li><li>由于Exchange 提供的路由算法，AMQP可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持队列和主题/订阅方式两种</li></ul><h3 id="常见的消息队列对比"><a href="#常见的消息队列对比" class="headerlink" title="常见的消息队列对比"></a>常见的消息队列对比</h3><img src= "/img/loading.gif" data-lazy-src="/2020/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/content7.png" class title="content7"><p>总结：</p><ul><li>ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用</li><li>RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。</li><li>RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ 挺好的</li><li>kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</li></ul>]]></content>
    
    
    <summary type="html">消息队列</summary>
    
    
    
    <category term="Java进阶" scheme="http://www.liuyewei.com/categories/Java%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="消息队列" scheme="http://www.liuyewei.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Markdown小结</title>
    <link href="http://www.liuyewei.com/2020/08/03/Markdown%E5%B0%8F%E7%BB%93/"/>
    <id>http://www.liuyewei.com/2020/08/03/Markdown%E5%B0%8F%E7%BB%93/</id>
    <published>2020-08-03T14:57:30.000Z</published>
    <updated>2020-09-07T13:51:00.506Z</updated>
    
    <content type="html"><![CDATA[<h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><h4 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗字段**</span><br><span class="line">__这也是加粗字段__</span><br></pre></td></tr></table></figure><h4 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*这是倾斜字段*</span><br><span class="line">_这也是倾斜字段_</span><br></pre></td></tr></table></figure><h4 id="又斜又粗"><a href="#又斜又粗" class="headerlink" title="又斜又粗"></a>又斜又粗</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">***斜粗字段***</span><br></pre></td></tr></table></figure><h4 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;这是高亮字段&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><h4 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2^2^</span><br></pre></td></tr></table></figure><h4 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H~2~o</span><br></pre></td></tr></table></figure><h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~加删除线的字段~~</span><br></pre></td></tr></table></figure><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;+一个空格+字段</span><br><span class="line">&gt;+五个空格+字段，引用代码块</span><br><span class="line">可以加若干个&gt;嵌套。多级引用</span><br></pre></td></tr></table></figure><h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">****</span><br></pre></td></tr></table></figure><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">![图片alt](图片地址 &quot;图片title&quot;)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure><h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br><span class="line">如果想要在新页面中打开的话可以用html语言的a标签代替。</span><br><span class="line">&lt;a href&#x3D;&quot;超链接地址&quot; target&#x3D;&quot;_blank&quot;&gt;超链接名&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure><h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure><p>列表嵌套<br>上一级和下一级之间敲三个空格即可</p><h4 id="表头"><a href="#表头" class="headerlink" title="表头"></a>表头</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>单行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\&#96;代码内容\&#96;</span><br></pre></td></tr></table></figure><p>代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\&#96;\&#96;\&#96;</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">  代码...</span><br><span class="line">\&#96;\&#96;\&#96;</span><br></pre></td></tr></table></figure><p>(使用时 反斜杠去掉)</p><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">op&#x3D;&gt;operation: My Operation</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?</span><br><span class="line">e&#x3D;&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><h4 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h4><p>行内嵌</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\sum_&#123;i&#x3D;1&#125;^&#123;10&#125;f(i)\,\,\text&#123;thanks&#125;$</span><br></pre></td></tr></table></figure><p>块状</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\sum_&#123;i&#x3D;1&#125;^&#123;10&#125;f(i)\,\,\text&#123;thanks&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h4 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h4><p>脚注和注脚一样吗，好像没区别<br>确保 [-] 里面的内容与底部的一致即可，可以是中文</p><h4 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h4><p>jump 可以用其他字符或字符串代替，id 一致即可<br>效果与脚注类似，可以跳转之文中任意位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[说明文字](#jump)</span><br><span class="line">&lt;span id&#x3D;&quot;jump&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠"></a>反斜杠</h4><p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号<br>例如：你想要用星号加在文字旁边的方式来做出强调效果（为了避免冲突）<br>你可以在星号的前面加上反斜杠，如果不加 \，# 后就会变为一级标题<br>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号</p><h4 id="转义箭头"><a href="#转义箭头" class="headerlink" title="转义箭头"></a>转义箭头</h4><p>\to 或 \rightarrow 与前面无空格<br>注意后面有空格！<br>之间若想空格，用 \ 加空格表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$A\to B$</span><br><span class="line">$C\rightarrow D$</span><br><span class="line">$C\Rightarrow D$</span><br><span class="line">$E\longrightarrow F$</span><br><span class="line">$A\Longleftrightarrow B$</span><br><span class="line">$A\xrightarrow&#123;\ \ \ \ 20km\quad&#125; B$</span><br><span class="line">$Beijin\xrightarrow&#123;10991km)\quad&#125; New York$</span><br></pre></td></tr></table></figure><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">居左：:----</span><br><span class="line">居中：:----:或-----</span><br><span class="line">居右：----:</span><br><span class="line"></span><br><span class="line">|标题|标题|标题|</span><br><span class="line">|:---|:---:|---:|</span><br><span class="line">|居左测试|居中测试|居右测试|</span><br><span class="line">|居左测试1|居中测试1|居右测试1|</span><br><span class="line">|居左测试2|居中测试2|居右测试2|</span><br><span class="line">|居左测试3|居中测试3|居右测试3|</span><br><span class="line"></span><br><span class="line">为了效果，我只能用HTML强制渲染了</span><br><span class="line">|标题|标题|标题|</span><br><span class="line">|:---|:---:|---:|</span><br><span class="line">|居左测试|&lt;center&gt;居中测试&lt;&#x2F;center&gt;|&lt;p align&#x3D;&quot;right&quot;&gt;居右测试&lt;&#x2F;p&gt;|</span><br><span class="line">|居左测试1|&lt;center&gt;居中测试1&lt;&#x2F;center&gt;|&lt;p align&#x3D;&quot;right&quot;&gt;居右测试1&lt;&#x2F;p&gt;|</span><br><span class="line">|居左测试2|&lt;center&gt;居中测试2&lt;&#x2F;center&gt;|&lt;p align&#x3D;&quot;right&quot;&gt;居右测试2&lt;&#x2F;p&gt;|</span><br><span class="line">|居左测试3|&lt;center&gt;居中测试3&lt;&#x2F;center&gt;|&lt;p align&#x3D;&quot;right&quot;&gt;居右测试3&lt;&#x2F;p&gt;|</span><br></pre></td></tr></table></figure><h4 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h4><p>任务列表即待办事项，表现为 方框 与 钩</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- [x] 早餐（已完成）</span><br><span class="line">- [ ] 喝水</span><br><span class="line">- [ ] 学习</span><br></pre></td></tr></table></figure><p>效果：</p><ul><li><input checked disabled type="checkbox"> 早餐（已完成）</li><li><input disabled type="checkbox"> 喝水</li><li><input disabled type="checkbox"> 学习</li></ul><p>基础markdown语法参考：<a href="https://www.appinn.com/markdown/">https://www.appinn.com/markdown/</a><br>插入数学公式markdown语法参考：<a href="https://www.zybuluo.com/codeep/note/163962">https://www.zybuluo.com/codeep/note/163962</a></p>]]></content>
    
    
    <summary type="html">Markdown小结</summary>
    
    
    
    <category term="工具" scheme="http://www.liuyewei.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Markdown" scheme="http://www.liuyewei.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>内外部类互访</title>
    <link href="http://www.liuyewei.com/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/"/>
    <id>http://www.liuyewei.com/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/</id>
    <published>2020-07-21T14:10:45.000Z</published>
    <updated>2020-09-07T13:50:29.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内部类访问外部类"><a href="#内部类访问外部类" class="headerlink" title="内部类访问外部类"></a>内部类访问外部类</h3><p>里面的可以自由访问外面的，规则和static一样。（访问非静态时必须先创建对象）具体如下：</p><ul><li><p>非静态内部类的非静态方法 直接访问</p><p>直接访问</p><img src= "/img/loading.gif" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content1.png" class title="content1"></li><li><p>静态内部类的非静态方法</p><p>因为静态方法访问非静态外部成员需先创建实例，所以访问i时必须先new外部类。</p><img src= "/img/loading.gif" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content2.png" class title="content2"></li><li><p>静态内部类的静态方法</p><p>规则如上</p><img src= "/img/loading.gif" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content3.png" class title="content3"></li></ul><h3 id="外部类访问内部类"><a href="#外部类访问内部类" class="headerlink" title="外部类访问内部类"></a>外部类访问内部类</h3><p>大方向：因为将内部类理解为外部类的一个普通成员，所以外面的访问里面的需先new一个对象。</p><ul><li><p>非静态方法访问非静态内部类的成员：</p><p>new 内部类对象</p><img src= "/img/loading.gif" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content4.png" class title="content4"></li><li><p>静态方法访问非静态内部类的成员</p><p>静态方法Test2访问非静态Inner1需先new外部类；</p><p>继续访问非静态成员i需先new 内部类</p><p>所以访问规则为：new Outter().new Inner1().i。</p><img src= "/img/loading.gif" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content5.png" class title="content5"></li><li><p>非静态方法访问静态内部类的成员</p><p>先“外部类.内部类”访问至内部类。</p><p>若访问静态成员，则需先new再访问；若访问非静态成员，则可直接访问。</p><img src= "/img/loading.gif" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content6.png" class title="content6"></li><li><p>非静态方法访问非静态内部类的成员</p><p>先“外部类.内部类”访问至内部类，再new即可访问静态成员。</p><img src= "/img/loading.gif" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content7.png" class title="content7"></li></ul><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类访问外部成员变量时，成员变量前应加final关键字。</p><img src= "/img/loading.gif" data-lazy-src="/2020/07/21/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB%E4%BA%92%E8%AE%BF/content8.png" class title="content8">]]></content>
    
    
    <summary type="html">内外部类</summary>
    
    
    
    <category term="Java" scheme="http://www.liuyewei.com/categories/Java/"/>
    
    
    <category term="内外部类" scheme="http://www.liuyewei.com/tags/%E5%86%85%E5%A4%96%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>自动拆装箱</title>
    <link href="http://www.liuyewei.com/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/"/>
    <id>http://www.liuyewei.com/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/</id>
    <published>2020-07-12T12:28:55.000Z</published>
    <updated>2020-09-07T13:46:32.271Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是自动装箱和拆箱"><a href="#什么是自动装箱和拆箱" class="headerlink" title="什么是自动装箱和拆箱"></a>什么是自动装箱和拆箱</h3><p>自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。原始类型byte, short, char, int, long, float, double 和 boolean 对应的封装类为Byte, Short, Character, Integer, Long, Float, Double, Boolean。</p><p>下面例子是自动装箱和拆箱带来的疑惑               </p><img src= "/img/loading.gif" data-lazy-src="/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/content1.png" class title="content1"> <img src= "/img/loading.gif" data-lazy-src="/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/content2.png" class title="content2">    <h3 id="自动装箱和拆箱的原理"><a href="#自动装箱和拆箱的原理" class="headerlink" title="自动装箱和拆箱的原理"></a>自动装箱和拆箱的原理</h3><p>自动装箱时编译器调用valueOf将原始类型值转换成对象，同时自动拆箱时，编译器通过调用类似intValue(),doubleValue()这类的方法将对象转换成原始类型值。明白自动装箱和拆箱的原理后，我们带着上面的疑问进行分析下Integer的自动装箱的实现源码。如下：</p><p>​        <img src= "/img/loading.gif" data-lazy-src="/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/content3.png" class title="content3"><br>        <img src= "/img/loading.gif" data-lazy-src="/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/content4.png" class title="content4"></p><p>Integer i1 = 40; 自动装箱，相当于调用了Integer.valueOf(40);方法。首先判断i值是否在-128和127之间，如果在-128和127之间则直接从IntegerCache.cache缓存中获取指定数字的包装类；不存在则new出一个新的包装类。</p><p>IntegerCache内部实现了一个Integer的静态常量数组，在类加载的时候，执行static静态块进行初始化-128到127之间的Integer对象，存放到cache数组中。cache属于常量，存放在java的方法区中。 </p><p>接着看下面是java8种基本类型的自动装箱代码实现。如下：</p><img src= "/img/loading.gif" data-lazy-src="/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/content6.png" class title="content6"><p>通过分析源码发现，只有double和float的自动装箱代码没有使用缓存，每次都是new 新的对象，其它的6种基本类型都使用了缓存策略。<br>使用缓存策略是因为，缓存的这些对象都是经常使用到的（如字符、-128至127之间的数字），防止每次自动装箱都创建一次对象的实例。<br>而double、float是浮点型的，没有特别的热的（经常使用到的）数据的，缓存效果没有其它几种类型使用效率高。<br>下面在看下装箱和拆箱问题解惑。</p><img src= "/img/loading.gif" data-lazy-src="/2020/07/12/%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/content7.png" class title="content7">]]></content>
    
    
    <summary type="html">自动装箱就是Java自动将原始类型值转换成对应的对象</summary>
    
    
    
    <category term="Java" scheme="http://www.liuyewei.com/categories/Java/"/>
    
    
    <category term="Java基础" scheme="http://www.liuyewei.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
